-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	'Select',
	605,
	'ACT_SEL',
	'This class represents a statement that selects a set of  instances.',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("d5f27817-25be-4a2c-86bf-8347c12b8c60",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	'dispose',
	'This operation disconnects an instance, and all instances it is 
responsible for, from the model.',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one sr related by self->ACT_SR[R664];
if ( not_empty sr )
  unrelate self from sr across R664;
  delete object instance sr;
end if;

select one srw related by self->ACT_SRW[R664];
if ( not_empty srw )
  unrelate self from srw across R664;
  select one val related by srw->V_VAL[R611];
  if ( not_empty val )
    unrelate srw from val across R611;
    val.dispose();
  end if;
  delete object instance srw;
end if;

select one var related by self->V_VAR[R638];
if ( not_empty var )
  unrelate self from var across R638;
  if ( not var.Declared )
    var.dispose();
  end if;
end if;

select one val related by self->V_VAL[R613];
if ( not_empty val )
  unrelate self from val across R613;
  val.dispose();
end if;

select one link related by self->ACT_LNK[R637];
if ( not_empty link )
  unrelate self from link across R637;
  while ( not_empty link )
    this_link = link;
    select one link related by this_link->ACT_LNK[R604.''precedes''];
    this_link.dispose();
  end while;
end if;
delete object instance self;
',
	1,
	'',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("7e745e88-3233-4bcb-ac06-b281ab39ff59",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	'execute',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Select.execute()
//select one <instance handle> related by <start> -> <relationship link> 
//->... <relationship link>;
//select any <instance handle> related by <start> -> <relationship link>
//-> ... <relationship link>;
//select many <instance handle set> related by <start> -> <relationship link>
//-> ... <relationship link>;
//select one <instance handle> related by <start> -> <relationship link>
// -> ... <relationship link> where <where expression>;
//select any <instance handle> related by <start> -> <relationship link>
//-> ... <relationship link> where <where expression>;
//select many <instance handle set> related by <start> -><relationship link>
//-> ... <relationship link> where <where expression>;
//
//<start> is an <instance handle set> or <instance handle> obtained from a 
//        previous select statement.
//<relationship link> is a <keyletter>[<relationship specification>], where the
//        square brackets are literal and do not indicate optional text.
//<keyletter> is the keyletter of the class reached by the specified relationship.
//<relationship specification> is the specification of the relationship from the source
//                             to the destination class.
//<where expression> is a type of boolean expression using the selected keyword.
//
//  Get the starting point instance handle(select one or any...)
select one body related by self->ACT_SMT[R603]->ACT_BLK[R602]->ACT_ACT[R601];
select one start_val related by self->V_VAL[R613];
select one start_var related by start_val->V_IRF[R801]->V_VAR[R808];  //  Check for a Variable via Instance Reference
if (empty start_var)
  select one start_var related by start_val->V_ISR[R801]->V_VAR[R809];  //  Check for a Variable via Instance Set Reference  
end if;
if (empty start_var)
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Select statement: Cannot locate starting variable",path:pathMsg);
  return;
end if;
// Get the starting point instance handle or set
select one start_ih related by start_var->V_INT[R814];
select one start_instance_set related by start_var->V_INS[R814];
// Grab the stack frame
select any stack_frame from instances of I_STF where
                              (selected.Stack_Frame_ID == param.stack_frame_id);
if (empty stack_frame)
  //Invalid stack frame ID!
  pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Select.execute: Invalid stack frame id used. Using random top stack frame.",path:pathMsg);
  select any stack from instances of I_STACK;
  select one stack_frame related by stack->I_STF[R2929];
end if;
// Get the local reference we will use in the loop to relate the instances
select any selection_local related by self->V_VAR[R638]->
                  V_INT[R814]->L_LCR[R3004]->L_LCL[R3001] where
                                selected.Stack_Frame_ID == param.stack_frame_id;
// If this is a many call, then selection_local_reference will be empty, and
// we should overwrite it with the correct value
if(self.cardinality == "many")
  select any selection_local related by self->V_VAR[R638]->
                  V_INS[R814]->L_LCR[R3003]->L_LCL[R3001] where
                                selected.Stack_Frame_ID == param.stack_frame_id;
end if;
select one selection_local_reference related by selection_local->L_LCR[R3001];
// If there is an inst in where instance, then the traversal was already
// performed and we are re-entering after executing a computed piece of the
// where clause. Therefore, skip the traversal and proceed directly to the
// where clause execution.
select any inst_in_where related by stack_frame->I_BSF[R2923]->
                                       L_LCL[R3000]->L_LSR[R3001]->L_IWC[R3006];
if (empty inst_in_where)
  // Perform the instance database traversal.
  //If this is the first time we are using this instance handle,
  // then create a new local reference in this block in stack frame
  if (self.is_implicit)
    // create the instance reference in the scope of the enclosing block
    select one block related by self->ACT_SMT[R603]->ACT_BLK[R602];
    ref_ID = block.newLocalReference(
                                    stack_frame_id: stack_frame.Stack_Frame_ID);
    select any selection_local_reference related by block->
                                  I_BSF[R2923]->L_LCL[R3000]->L_LCR[R3001] where
                                                  (selected.Local_ID == ref_ID);
    if(self.cardinality == "many")
       select one selection_inst_set related by self->V_VAR[R638]->V_INS[R814];
       relate selection_inst_set to selection_local_reference across R3003;
    else
       select one selection_ih related by self->V_VAR[R638]->V_INT[R814];
       relate selection_ih to selection_local_reference across R3004;
    end if;
  end if;
  // Set value to this block with the right type so we can use it later. The value here is useless.
  select any start_local_reference from instances of L_LCR;
  // Get all of the block in stack frames that exist for the stack frame
  select many block_in_stack_frames related by stack_frame->I_BSF[R2923];
  // Find the one local reference that matches the block in stack frame where we are executing
  // WARNING: This implementation is based on the Object Action Language definition that existed in November of 2005.
  //          If the language is changed to become a strongly typed language where a user can define a variable in an inner block with the same
  //          name as something that exists in the outer block, then this implementation will not work because it does not walk out of the current
  //          block.
  if (not_empty start_ih)
    select any start_local_reference related by block_in_stack_frames->
            L_LCL[R3000]->L_LCR[R3001] where selected.Var_ID == start_ih.Var_ID;
  elif (not_empty start_instance_set)
    select any start_local_reference related by block_in_stack_frames->
                                                L_LCL[R3000]->L_LCR[R3001] where
                                   selected.Var_ID == start_instance_set.Var_ID;
  else
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Select.execute.  Did not find a starting point instance handle or set.",path:pathMsg);
    return;
  end if;
  if (empty start_local_reference)
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty body)
      pathMsg = body.getPath();
    end if;
	USER::logError(msg:"Error in Select.execute.  Did not find a starting point reference handle.",path:pathMsg);
    return;
  end if;
  // At this point we are done with getting the starting point
  // Now, get all the instances related to this local reference regardless of
  // instance handle or set. This gives us all the relevant instances at the
  // starting point of this related by statement.
  select many start_instances related by start_local_reference->
                             L_LCL[R3001]->RV_RVL[R3306]->RV_SMV[R3300]->
                                      RV_IRV[R3308]->L_IIR[R3311]->I_INS[R3013];
  // Since we already have the instance set to use for this link, empty out the
  // local reference so we can populate it with only the relevant instances for
  // the latest chain link
  selection_local_reference.clear();
  // Set up the starting point for the traversal
  for each inst in start_instances
    selection_local_reference.addInstance(inst_id:inst.Inst_ID);
  end for;
  select many selection_inst_refs related by selection_local_reference->
                                              L_LCL[R3001]->RV_RVL[R3306]->
                                     RV_SMV[R3300]->RV_IRV[R3308]->L_IIR[R3311];
  // Get the first link in the chain
  select one chain_link related by self->ACT_LNK[R637];
  while (not_empty chain_link and not_empty selection_inst_refs)
    // Get the next link in the chain
    select one next_link related by chain_link->ACT_LNK[R604.''precedes''];  
    // Get the association related to this chain link and all the links related
    // to that association
    select one association related by chain_link->R_REL[R681];
    select one assoc_class related by association->R_ASSOC[R206]->
                            R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
    select one form related by association->R_SIMP[R206]->R_FORM[R208];
    select one super related by association->R_SUBSUP[R206]->R_SUPER[R212];
    select any part related by
                            association->R_SIMP[R206]->R_PART[R207] where
                                        selected.Rel_ID == GD::NULL_UNIQUE_ID();
    fromPart = part;
    select one aone related by association->R_ASSOC[R206]->R_AONE[R209];
    select one aoth related by association->R_ASSOC[R206]->R_AOTH[R210];
    // Decide whether we are navigating an associative instance
    from_assoc = false;
    to_assoc = false;
    // These are all instances of the same class, so select any is safe here
    select any source_class related by selection_inst_refs->I_INS[R3013]->
                                                  CSME_CIE[R2962]->O_OBJ[R2961];
    select one target_class related by chain_link->O_OBJ[R678];
    if not_empty assoc_class
      if (source_class  == assoc_class)
        from_assoc = true;
      end if;
      if (target_class == assoc_class)
        to_assoc = true;
      end if;
    end if; // not empty association class
    traverseFwd = true;
    checkFwd = true; // separate flag until we clean up traverse forward/back.
    traverseBack = true;
    targetPhrase = GD::strip_tics(value:chain_link.Rel_Phrase);
    // Unformalized associations have 2 participants and no formalizer
    // Support this kind of association by allowing for 2 part instances
    select many parts related by association->R_SIMP[R206]->R_PART[R207];
    if (association.is_reflexive()) // Reflexive case
      // selecting many parts above allows operation with unformalized assocs
      // Here we find which of the informal parts is the ''forward'' direction
      if empty form and empty aone // unformalized and non link association
        partCount = 1;
        for each candidatePart in parts
          if (partCount == 1)
            fromPart = candidatePart;
            if (candidatePart.Txt_Phrs == targetPhrase)
              // the user wants to go from the other side to the one
              traverseFwd = false;
              checkFwd = false;
            else
              // the user wants to go from one side to the other side
              traverseBack = false;
            end if;
          else //(candidatePart.Txt_Phrs == sourcePhrase)
            part = candidatePart;
          end if;
          partCount = partCount + 1;
        end for;
      end if;
      if not_empty form // formalized
        if form.Txt_Phrs == targetPhrase
          // the user wants to go from other side to the one
          traverseFwd = false;
          checkFwd = false;
        else
          // the user wants to go from one side to the other
          traverseBack = false;
        end if;
        select any part related by association->R_SIMP[R206]->R_PART[R207];
      end if; // formalized case
      if (not_empty aone and aone.Txt_Phrs == targetPhrase) // linked assoc
        // the user wants to go from other side to one side
        traverseFwd = false;
        checkFwd = false;
      end if;
      if (not_empty aoth and aoth.Txt_Phrs == targetPhrase) // linked assoc
        // the user wants to go from one side to the other
        traverseBack = false;
      end if;
    else // not reflexive
      if empty super
        if empty form
          // Find which of the informal parts is the ''forward'' direction
          partCount = 1;
          for each candidatePart in parts
            if partCount == 1
              fromPart = candidatePart;
            else
              part = candidatePart;
            end if;
            partCount = partCount + 1;
          end for;
        else // not_empty form
          select any part related by association->R_SIMP[R206]->R_PART[R207];
        end if; // 
        select one cia related by part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
        if not_empty aoth
          select one cia related by aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
        end if;
        if cia == source_class
          checkFwd = false;
        end if;
      else
        select one cia related by super->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
        if cia == source_class
          checkFwd = false;
        end if;
      end if;
    end if; // end reflexive - non-reflexive case
    // Go through all the instances from the previous link in the chain and see
    // if they are related to any of the instances in the current chain link.
    for each inst_in_ref in selection_inst_refs
      select one inst related by inst_in_ref->I_INS[R3013];
      inst_in_ref.dispose();
      // Now build the instance set . . .
      if (from_assoc)
        select many links related by inst->I_LIP[R2958]->I_LNK[R2903];
        for each link in links
          // if this link is an instance of the association we''re traversing.
          select one link_assoc related by link->R_REL[R2904];
          if (link_assoc == association)
            if (traverseBack)
              select one inst_src related by link->I_LIP[R2901]->I_INS[R2958];
              select one src_class related by inst_src->
                                                  CSME_CIE[R2962]->O_OBJ[R2961];
              // and if the class of this instance is the desired class . . . 
              if (src_class == target_class)
                selection_local_reference.addInstance(inst_id:inst_src.Inst_ID);
              end if;
            end if;
            // consider both legs of the link
            if (traverseFwd)
              select one inst_dest related by link->I_LIP[R2902]->I_INS[R2958];
              select one dest_class related by inst_dest->
                                                  CSME_CIE[R2962]->O_OBJ[R2961];
              // and if the class of this instance is the desired class . . . 
              if (dest_class == target_class)
                selection_local_reference.addInstance(
                                                     inst_id:inst_dest.Inst_ID);
              end if;
            end if;
          end if;
        end for; // each link
      else  // not coming from an associative
        // This handles all other cases, simple and link associations, reflexive
        // and non-reflexive, formalized or not. If unformalized, link instances
        // can exist in either direction, so we use the target class identity
        // to determine the correct instances to add to the result.
        if (traverseFwd)
          select many links related by inst->I_LIP[R2958]->I_LNK[R2901];
          for each link in links
            // if this link is an instance of the association we''re traversing.
            select one link_assoc related by link->R_REL[R2904];
            if (link_assoc == association)
              select one inst_dest related by link->I_LIP[R2902]->I_INS[R2958];
              if (to_assoc)
                select one inst_dest related by link->
                                                     I_LIP[R2903]->I_INS[R2958];
              end if;
              select one dest_class related by inst_dest->
                                                  CSME_CIE[R2962]->O_OBJ[R2961];
              if (dest_class == target_class)
                selection_local_reference.addInstance(
                                                     inst_id:inst_dest.Inst_ID);
              end if;
            end if;
          end for; // each link
        end if;
        // consider both directions of the link
        if (traverseBack)
          select many links related by inst->I_LIP[R2958]->I_LNK[R2902];
          for each link in links
            // if this link is an instance of the association we''re traversing.
            select one link_assoc related by link->R_REL[R2904];
            if (link_assoc == association)
              select one inst_dest related by link->I_LIP[R2901]->I_INS[R2958];
              if (to_assoc)
                select one inst_dest related by link->
                                                     I_LIP[R2903]->I_INS[R2958];
              end if;
              select one dest_class related by inst_dest->
                                                  CSME_CIE[R2962]->O_OBJ[R2961];
              if (dest_class == target_class)
                selection_local_reference.addInstance(
                                                     inst_id:inst_dest.Inst_ID);
              end if;
            end if;
          end for; // each link
        end if;
      end if; // coming from an associative
    end for; // each instance in a reference
    // Get a new instance set to use for the next link in the chain.
    select many selection_inst_refs related by selection_local_reference->
                                                L_LCL[R3001]->RV_RVL[R3306]->
                                     RV_SMV[R3300]->RV_IRV[R3308]->L_IIR[R3311];
    if (PREF::getBoolean(name:"bridgepoint_prefs_enable_verifier_audit")== true)
      auditSev = PREF::getInteger(name:"bridgepoint_prefs_enable_select_audit"); 
      if auditSev != 0  // 0 == Ignore
        if cardinality selection_inst_refs == 0;
          cond = 0;
          if checkFwd
            if not_empty aoth
              cond = aoth.Cond;
            elif not_empty part
              cond = part.Cond;
            // super case: traversing to supertype, is default unconditional
            end if;
          else // traverse backwards
            if not_empty aone
              cond = aone.Cond;
            elif not_empty form
              cond = form.Cond;
            elif not_empty fromPart
              cond = fromPart.Cond;
            elif not_empty super
              cond = 1; // traversing from supertype, any subtype is conditional
            end if;
          end if;
          if (cond == 0)  // 0 == Unconditional
            severity = "Warning";
            assocPhrase = "";
            if (targetPhrase != "")
              assocPhrase = " (" + targetPhrase + ")";
            end if;
            postFixMsg = "";
            if auditSev == 2 // 2 == FATAL
              severity = "FATAL";
              select one stack related by stack_frame->I_STACK[R2929];
              stack.suspendReason = "Halted on illegal link instance " +
                        "population on " + association.get_name() + assocPhrase;
              stack.runState = RunStateType::Suspended;
              postFixMsg = GD::newline() + "Execution Halted.  (Problem detected at previous statement)";
            else // 1 == Warning
              select one statement related by self->ACT_SMT[R603];
              postFixMsg = " at: " + statement.Label;
            end if;
            message = severity + " Select: Unexpected empty population " +
                        "found while traversing unconditional association " +
                              association.get_name() + assocPhrase + postFixMsg;
            USER::logError(msg:message,path:body.getPath());
          end if;
        end if;
      end if;
    end if;
    // Set the next link in the chain
    chain_link = next_link;
  end while;
end if;
select one where_selection related by self->ACT_SRW[R664];
select any result related by selection_local_reference->L_LCL[R3001]->
                      RV_RVL[R3306]->RV_SMV[R3300]->RV_IRV[R3308]->L_IIR[R3311];
// If there is a where clause and there are instances to filter . . . 
if (not_empty where_selection and not_empty result)
  where_selection.execute(stack_frame_id: stack_frame.Stack_Frame_ID);
end if;
select any inst_in_where related by stack_frame->I_BSF[R2923]->
                                       L_LCL[R3000]->L_LSR[R3001]->L_IWC[R3006];
if (empty inst_in_where)
  // This has to be done after the where clause has completed processing
  // (i.e. inst in where is empty) . . . 
  if (self.cardinality == "any" or self.cardinality == "one")
    // Leave only the first instance found in the set . . .
    select any selection_local_reference related by self->
                                         V_VAR[R638]->V_INT[R814]->L_LCR[R3004];
    select many iirs related by selection_local_reference->L_LCL[R3001]->
                      RV_RVL[R3306]->RV_SMV[R3300]->RV_IRV[R3308]->L_IIR[R3311];
    foundResult = false;
    for each iir in iirs
      if (not foundResult)
        foundResult = true;
      else
        iir.dispose();
      end if;
    end for;
  else // self.cardinality == "many"
    // remove all duplicates from the set
    select many iirs related by selection_local_reference->L_LCL[R3001]->
                      RV_RVL[R3306]->RV_SMV[R3300]->RV_IRV[R3308]->L_IIR[R3311];
    for each iir in iirs
      select one inst related by iir->I_INS[R3013];
      if not_empty inst
        // select the full set of which this reference is a member
        select many potentialDuplicates related by iir->
                                                    RV_IRV[R3311]->L_IIR[R3311];
        originalFound = false;
        for each potentialDuplicate in potentialDuplicates
          select one potentialDuplicateInst related by
                                               potentialDuplicate->I_INS[R3013];
          if potentialDuplicateInst == inst
            if originalFound
              potentialDuplicate.dispose(); // remove the reference from set
            else
              originalFound = true; // keep first reference to this instance
            end if;
          end if; // we found a matching instance reference
        end for; // each potentialDuplicate
      end if; // inst is empty (iir was already disposed when visited)
    end for; // each instanceInReference
  end if;
end if;',
	1,
	'',
	"d5f27817-25be-4a2c-86bf-8347c12b8c60");
INSERT INTO O_TPARM
	VALUES ("f996f68c-a240-46d0-b5ca-0bbb95ba00c2",
	"7e745e88-3233-4bcb-ac06-b281ab39ff59",
	'stack_frame_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_REF
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"4f42b756-0c2e-4a87-b40f-87291682433c",
	0,
	"9bdc49e0-583c-4741-ad6c-fa52d80977a5",
	"df5d83da-30d6-4d47-b2e9-e0558c45efd8",
	"7e2512fd-5a88-4c84-9e5e-ef46326d8812",
	"7558839e-e4fb-46e4-97b0-decfec373abb",
	"94bf419b-d5d2-4c27-b9d1-8e4f7d60833a",
	"c67b72b3-4f3c-48c3-b3d6-4138b3dab1d6",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'Statement',
	'Statement_ID',
	'R603');
INSERT INTO R_RGO_PROXY
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"df5d83da-30d6-4d47-b2e9-e0558c45efd8",
	"7e2512fd-5a88-4c84-9e5e-ef46326d8812",
	'../../Body/Body.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("9bdc49e0-583c-4741-ad6c-fa52d80977a5",
	"4f42b756-0c2e-4a87-b40f-87291682433c",
	0,
	"df5d83da-30d6-4d47-b2e9-e0558c45efd8",
	"7558839e-e4fb-46e4-97b0-decfec373abb",
	'../../Body/Body.xtuml');
INSERT INTO O_RATTR
	VALUES ("94bf419b-d5d2-4c27-b9d1-8e4f7d60833a",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"9bdc49e0-583c-4741-ad6c-fa52d80977a5",
	"4f42b756-0c2e-4a87-b40f-87291682433c",
	1,
	'Statement_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("9bdc49e0-583c-4741-ad6c-fa52d80977a5",
	"4f42b756-0c2e-4a87-b40f-87291682433c",
	'../../Body/Statement/Statement.xtuml');
INSERT INTO O_ATTR
	VALUES ("94bf419b-d5d2-4c27-b9d1-8e4f7d60833a",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"00000000-0000-0000-0000-000000000000",
	'Statement_ID',
	'

',
	'',
	'Statement_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_REF
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"f8c82d33-e7c5-4fb7-8c3c-77b2a47feca7",
	0,
	"5b3f451e-a4bf-4d7c-97db-547eae3c84ae",
	"d8485749-eaff-4171-b435-885d66ce53df",
	"ad71edd6-5763-4e31-bb07-dc8d1d50d4fe",
	"8ca6d698-88ba-41e3-9272-f1768599422f",
	"13fc637d-2f51-4c9c-8f29-a0746d725191",
	"e691377f-bafb-4ebe-a705-f7af895709d8",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'Variable',
	'Var_ID',
	'R638.''selection''');
INSERT INTO R_RGO_PROXY
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"d8485749-eaff-4171-b435-885d66ce53df",
	"ad71edd6-5763-4e31-bb07-dc8d1d50d4fe",
	'../Selection.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("5b3f451e-a4bf-4d7c-97db-547eae3c84ae",
	"f8c82d33-e7c5-4fb7-8c3c-77b2a47feca7",
	0,
	"d8485749-eaff-4171-b435-885d66ce53df",
	"8ca6d698-88ba-41e3-9272-f1768599422f",
	'../Selection.xtuml');
INSERT INTO O_RATTR
	VALUES ("13fc637d-2f51-4c9c-8f29-a0746d725191",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"5b3f451e-a4bf-4d7c-97db-547eae3c84ae",
	"f8c82d33-e7c5-4fb7-8c3c-77b2a47feca7",
	1,
	'Var_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("5b3f451e-a4bf-4d7c-97db-547eae3c84ae",
	"f8c82d33-e7c5-4fb7-8c3c-77b2a47feca7",
	'../../Value/Variable/Variable.xtuml');
INSERT INTO O_ATTR
	VALUES ("13fc637d-2f51-4c9c-8f29-a0746d725191",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"94bf419b-d5d2-4c27-b9d1-8e4f7d60833a",
	'Var_ID',
	'

',
	'',
	'Var_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("00c0932f-6f86-4a31-ae49-608085fce793",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_BATTR
	VALUES ("00c0932f-6f86-4a31-ae49-608085fce793",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_ATTR
	VALUES ("00c0932f-6f86-4a31-ae49-608085fce793",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"13fc637d-2f51-4c9c-8f29-a0746d725191",
	'is_implicit',
	'Full Name: Is Implicit
Specifies whether the resulting instance handle found by traversing
R638 is being used for the first time in this scope or not.',
	'',
	'is_implicit',
	0,
	"ba5eda7a-def5-0000-0000-000000000001",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("5fa98335-c12e-491e-87f9-e2723fff0929",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_BATTR
	VALUES ("5fa98335-c12e-491e-87f9-e2723fff0929",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_ATTR
	VALUES ("5fa98335-c12e-491e-87f9-e2723fff0929",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"00c0932f-6f86-4a31-ae49-608085fce793",
	'cardinality',
	'Full Name: Selection Cardinality
Specifies whether the selection produces a set or an instance as a result.  The cardinality value can be one of the following: one, any, or many.',
	'',
	'cardinality',
	0,
	"ba5eda7a-def5-0000-0000-000000000004",
	'',
	'');
INSERT INTO O_REF
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"43ea4f47-4fe8-4167-8153-9e199477d0fd",
	0,
	"6e185a42-0dc6-4b9d-9d4b-38cb7c8aa772",
	"385b9e98-5a39-4dd4-a0f6-89c0587a026c",
	"40bfa9f1-5120-427c-929e-aa58616b68b0",
	"1f3999e6-eeee-41a0-871f-d0cb9b54b1ea",
	"537740a3-0284-4eb1-802f-1b1e43ef62e0",
	"8ad285b2-b523-4f22-8983-bd4bd22fbd46",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'Value',
	'Value_ID',
	'R613.''starting point''');
INSERT INTO R_RGO_PROXY
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"385b9e98-5a39-4dd4-a0f6-89c0587a026c",
	"40bfa9f1-5120-427c-929e-aa58616b68b0",
	'../Selection.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("6e185a42-0dc6-4b9d-9d4b-38cb7c8aa772",
	"43ea4f47-4fe8-4167-8153-9e199477d0fd",
	0,
	"385b9e98-5a39-4dd4-a0f6-89c0587a026c",
	"1f3999e6-eeee-41a0-871f-d0cb9b54b1ea",
	'../Selection.xtuml');
INSERT INTO O_RATTR
	VALUES ("537740a3-0284-4eb1-802f-1b1e43ef62e0",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"6e185a42-0dc6-4b9d-9d4b-38cb7c8aa772",
	"43ea4f47-4fe8-4167-8153-9e199477d0fd",
	1,
	'Value_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("6e185a42-0dc6-4b9d-9d4b-38cb7c8aa772",
	"43ea4f47-4fe8-4167-8153-9e199477d0fd",
	'../../Value/Value/Value.xtuml');
INSERT INTO O_ATTR
	VALUES ("537740a3-0284-4eb1-802f-1b1e43ef62e0",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	"5fa98335-c12e-491e-87f9-e2723fff0929",
	'Value_ID',
	'

',
	'',
	'Value_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_OIDA
	VALUES ("94bf419b-d5d2-4c27-b9d1-8e4f7d60833a",
	"b1a1c65e-e119-4b5d-9356-c493fdaada15",
	0,
	'Statement_ID');
INSERT INTO O_ID
	VALUES (1,
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO O_ID
	VALUES (2,
	"b1a1c65e-e119-4b5d-9356-c493fdaada15");
INSERT INTO PE_PE
	VALUES ("b1a1c65e-e119-4b5d-9356-c493fdaada15",
	1,
	"506c7424-c813-4e1c-8551-b157c3aa6f07",
	"00000000-0000-0000-0000-000000000000",
	4);
INSERT INTO EP_PKG_PROXY
	VALUES ("506c7424-c813-4e1c-8551-b157c3aa6f07",
	"00000000-0000-0000-0000-000000000000",
	"2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'Selection',
	'This subsystem captures concepts related to selections of instances across associations. Association chain, where and instance extent selections are also covered.
Notify_Changes:false
Persistent:false
// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
',
	600,
	'../Selection.xtuml');
