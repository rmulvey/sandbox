-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'Transition',
	508,
	'SM_TXN',
	'A transition represents a change in state of an instance.  It is represented by a line between to states (SM_NETXN and SM_NSTXN), or a line into a single state (SM_CRTXN).  Transitions are labeled with a single event (SM_EVT).',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("8c23089d-4120-4409-ac99-0aa46872aa74",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'get_connector_text',
	'Returns the empty string for all ends except the Middle. In this case,
it selects the subtype and delegates the call.
-----------------------------------------------------------------------------------
Bridge:GD
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'result = "";
if (param.at == End::Middle)
  select one nst related by self->SM_NSTXN[R507];
  if (not_empty nst)
    result = nst.get_connector_text();
  end if;
  select one net related by self->SM_NETXN[R507];
  if (not_empty net)
    result = net.get_connector_text();
  end if;
  select one action related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
  if not_empty action and action.Action_Semantics != ""
    result = result + "/";
    if PREF::getBoolean(name:"bridgepoint_prefs_show_transition_actions")
      result = result + GD::newline() + action.Action_Semantics;
    else
      result = result + "...";
    end if;
  end if;
end if;
return result;',
	1,
	'',
	"49f51099-e00d-4a33-b5df-d6a6310ecc50");
INSERT INTO O_TPARM
	VALUES ("e4e71e01-a19a-4570-bcb5-e1982a194902",
	"8c23089d-4120-4409-ac99-0aa46872aa74",
	'OOA_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("3f7c4cef-c7fb-47b8-9431-736acc55ce22",
	"8c23089d-4120-4409-ac99-0aa46872aa74",
	'OOA_TypeIsImportedClass',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e4e71e01-a19a-4570-bcb5-e1982a194902",
	'');
INSERT INTO O_TPARM
	VALUES ("d6070a6b-2b8d-4f81-97fc-643c96782b5c",
	"8c23089d-4120-4409-ac99-0aa46872aa74",
	'at',
	"f9390a28-d78e-4364-b005-bcf6767b5871",
	0,
	'',
	"3f7c4cef-c7fb-47b8-9431-736acc55ce22",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f9390a28-d78e-4364-b005-bcf6767b5871",
	"00000000-0000-0000-0000-000000000000",
	'End',
	'Text is positioned at a user adjustable offset from the Start, Middle and End of a connector. Start_Fixed and End_Fixed specify fixed position text found at the start and end of some connectors.
-------------------------------------------------------------
Bridge:GD',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO O_TPARM
	VALUES ("5579f557-e54d-437a-b168-590c7be84804",
	"8c23089d-4120-4409-ac99-0aa46872aa74",
	'parent_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"d6070a6b-2b8d-4f81-97fc-643c96782b5c",
	'');
INSERT INTO O_TFR
	VALUES ("2db70c57-8fdd-4285-ad1a-c8885c3bd09c",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'get_style',
	'Most Transitions have an arrow at the end and no adornment at the
start. The exception is the Creation Transition which has it''s own
get_style operation, called from here when necessary.
-----------------------------------------------------------------------------------
Bridge:GD',
	"05be3a7b-3886-4857-8a5e-5c08c37293ab",
	1,
	'select one crt related by self->SM_CRTXN[R507];
if (not_empty crt)
  return crt.get_style(at:param.at);
else
  if (param.at == End::End)
    return Style::OpenArrow;
  else
    return Style::None;
  end if;
end if;',
	1,
	'',
	"973da2df-e903-47cd-98b0-62a49fa38b2f");
INSERT INTO O_TPARM
	VALUES ("d147594c-588c-4ef0-9044-6145a6844fd7",
	"2db70c57-8fdd-4285-ad1a-c8885c3bd09c",
	'at',
	"f9390a28-d78e-4364-b005-bcf6767b5871",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("05be3a7b-3886-4857-8a5e-5c08c37293ab",
	"00000000-0000-0000-0000-000000000000",
	'Style',
	'The Style data type specifies the precise form a graphical element will take when drawn.
--------------------------------------------------------------------------
Bridge:GD',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO O_TFR
	VALUES ("49f51099-e00d-4a33-b5df-d6a6310ecc50",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'dispose',
	'Dispose this Transition.',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one nstxn related by self->SM_NSTXN[R507];
if (not_empty nstxn)
  select one sig related by nstxn->SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
  if (not_empty sig)
    self.removeSignal();
  else
    // migrate to a No Event Transition (SM_NETXN)
    // which will be deleted below
    self.removeEvent();
  end if;
end if;
                                   
select one crtxn related by self->SM_CRTXN[R507];
if (not_empty crtxn)
  self.removeEvent();
  unrelate self from crtxn across R507;
  delete object instance crtxn;
end if; 
select one netxn related by self->SM_NETXN[R507];
if (not_empty netxn)
  unrelate self from netxn across R507;
  select one state related by netxn->SM_STATE[R508];
  unrelate netxn from state across R508;
  delete object instance netxn;
end if;
                                   
select one sm related by self->SM_SM[R505];
unrelate self from sm across R505;
select one state related by self->SM_STATE[R506];
unrelate self from state across R506;
select one act related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
if (not_empty act )
  act.dispose();
else
  // the dispose unit tests don''t populate everything
  select one meah related by self->SM_MEAH[R512];
  if ( not_empty meah )
    select one mealy related by meah->SM_MEALY[R512];
    unrelate mealy from self across R512 using meah;
  end if;
end if;
select many insts related by self->I_INS[R2953];
for each inst in insts
  unrelate self from inst across R2953;
end for;
select many classInStates related by self->CSME_CIS[R2952];
for each classInState in classInStates
  classInState.dispose();
end for;
delete object instance self;',
	1,
	'',
	"11c18895-50c3-4135-bb79-aafdb17e5e4f");
INSERT INTO O_TFR
	VALUES ("973da2df-e903-47cd-98b0-62a49fa38b2f",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'get_ooa_id',
	'The ooa_id of a Transition is its Trans_ID
-----------------------------------------------------------
Bridge:GD',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'return self.Trans_ID;',
	1,
	'',
	"a55a875f-15d9-4608-bf6c-62e419288692");
INSERT INTO O_TFR
	VALUES ("e3dcfdf1-8a63-4967-be64-ec5061083550",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'actionFilter',
	'Bridge: UI
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'if (param.name == "event" )
  
  if (param.value == "exists spec pkg" ) or (param.value == "exists generic pkg" )
  
    select one cls related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
    end if;

    if (param.value == "exists spec pkg")
      return false;
    end if;
      
    // might want to enforce data set consistency here
    // i.e. events only exist if they match the state''s data set
    select one net related by self->SM_NETXN[R507];
    select one nst related by self->SM_NSTXN[R507];
    select one ct related by self->SM_CRTXN[R507];
    select one stateMachine related by self->SM_SM[R505];
    select many selfTypeEvents related by stateMachine->SM_EVT[R502];
    
	// if this transition belongs to an instance state machine, and is not
	// a creation transition
	select one instanceStateMachine related by stateMachine->SM_ISM[R517];
	numSupertypeEvents = 0;
	numSelfTypeEvents = cardinality selfTypeEvents;
	if (not_empty instanceStateMachine and empty ct)
		// for each event in the domain
		select many events from instances of SM_EVT;
		for each event in events
			// if this event does not belong to this transition''s state machine,
			// but is assignable to this transition''s state machine
			if (event.SM_ID != self.SM_ID 
				and event.isAssignableToStateMachine(
					assignToMachineId:self.SM_ID, isCreationTransition:false))
				// there is one more supertype event which might possibly
				// be assigned to this transition
				numSupertypeEvents = numSupertypeEvents + 1;
			end if;
		end for;	
		
		// for each event that belongs to this transition''s state machine
	    select many events related by stateMachine->SM_EVT[R502]; 
		for each event in events
			// if this event is assigned in a subtype state machine
			if (event.isAssignedInSubtypeStateMachine(
				supertypeId:instanceStateMachine.Obj_ID))
				// there is one less self-type event which might possibly
				// be assigned to this transition 			
				numSelfTypeEvents = numSelfTypeEvents - 1;
			end if;
		end for;
    else	
      select many events related by stateMachine->SM_EVT[R502]; 
	  for each event in events
	    // if this event is a signal event
	    select one sigEvt related by event->SM_SEVT[R525]->SM_SGEVT[R526];
	    if not_empty sigEvt
          // there is one less self-type event which might possibly
          // be assigned to this transition 			
          numSelfTypeEvents = numSelfTypeEvents - 1;
		end if;
	  end for;
	end if;

    if (not_empty net)
      select one state related by net->SM_STATE[R508];
      select many newStateTransitions related by state->
                                                  SM_SEME[R503]->SM_NSTXN[R504];
      // We discounted signals above, so we need to
      // discount transitions with signals here.
      select many signalDrivers related by newStateTransitions->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
      eventDrivenNewStateTransitions = cardinality newStateTransitions -
                                                      cardinality signalDrivers;
      return numSelfTypeEvents + numSupertypeEvents >
                                                 eventDrivenNewStateTransitions;
    elif (not_empty nst)
      select one state related by nst->SM_SEME[R504]->SM_STATE[R503];    
      select many newStateTransitions related by state->
                                                  SM_SEME[R503]->SM_NSTXN[R504];
      // discount signal driven transitions.
      select many signalDrivers related by newStateTransitions->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
      eventDrivenNewStateTransitions = cardinality newStateTransitions -
                                                      cardinality signalDrivers;
      return numSelfTypeEvents + numSupertypeEvents >
                                                 eventDrivenNewStateTransitions;
    elif (not_empty ct)
      select one state related by self->SM_STATE[R506];          
      select many creationTransitionsAssigned related by selfTypeEvents
      	                         ->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
      return numSelfTypeEvents > cardinality creationTransitionsAssigned;
    end if;  

  elif (param.value == "assigned" )
    select one levt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                   SM_SEVT[R503]->SM_LEVT[R526];
    if empty levt
      select one levt related by self->SM_CRTXN[R507]->SM_LEVT[R509];
    end if;
    return not_empty levt;
  end if;
elif param.name == "signal"
  if (param.value == "exists spec pkg") or (param.value == "exists generic pkg") 
    select one cls related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
    if (empty cls)
      select one cls related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
    end if;
    select one packageableElem related by cls->PE_PE[R8001];
    select one package related by packageableElem->EP_PKG[R8000];
    // Currently component will always be null, but this may change
    select one component related by packageableElem->C_C[R8003];
    if not_empty package
      compId = package.getContainingComponentId();
      select any component from instances of C_C where (selected.Id == compId);
    end if;
    isInGenericPackage = not_empty package or not_empty component;
    // if there is no containing component, then this action should be
    // filtered
    if(empty component)
      return false;
    end if;
    if ((param.value == "exists spec pkg"))
      return false;
    end if;
      
    select many provisions related by component->
                                           C_PO[R4010]->C_IR[R4016]->C_P[R4009];
    for each provision in provisions
      if provision.hasAvailableSignalsFor(transition_id:self.Trans_ID)
        return true;
      end if;
    end for;
    select many requirements related by component->
                                           C_PO[R4010]->C_IR[R4016]->C_R[R4009];
    for each requirement in requirements
      if requirement.hasAvailableSignalsFor(transition_id:self.Trans_ID)
        return true;
      end if;
    end for;
  elif param.value == "assigned"
    select one sgEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                  SM_SEVT[R503]->SM_SGEVT[R526];
    return not_empty sgEvt;
  end if;
end if;
return false;',
	1,
	'',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TPARM
	VALUES ("4c68242e-7489-4328-9c50-feeae215bbed",
	"e3dcfdf1-8a63-4967-be64-ec5061083550",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("04bc4c06-f73a-4614-a19f-0a77a7638ebf",
	"e3dcfdf1-8a63-4967-be64-ec5061083550",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4c68242e-7489-4328-9c50-feeae215bbed",
	'');
INSERT INTO O_TFR
	VALUES ("7713fe33-c434-4a8e-80d6-d745769cb806",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'addEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// find the event corresponding to the one given that is associated with 
// this transition''s state machine, which in fact may be the one given, or not
// if the given event is polymorphic
select any event from instances of SM_EVT 
	where selected.SMevt_ID == param.eventId
		and selected.SM_ID == param.eventStateMachineId;
select one sm related by self->SM_SM[R505];
eventId = event.getAssociatedEventForStateMachine(stateMachineId:sm.SM_ID);
select any event from instances of SM_EVT where selected.SMevt_ID == eventId;
 		
 select one no_evt_txn related by self->SM_NETXN[R507];
 if ( not_empty no_evt_txn )
   select one orig_state related by no_evt_txn->SM_STATE[R508];
   unrelate no_evt_txn from orig_state across R508;
   unrelate no_evt_txn from self across R507;
   delete object instance no_evt_txn;
   create object instance ns_txn of SM_NSTXN;
   relate self to ns_txn across R507;
   
   select any seme related by orig_state->SM_SEME[R503] 
       where selected.SMevt_ID == event.SMevt_ID;
   seme.disposeChOrEi();
   relate ns_txn to seme across R504;
 else
   select one ns_txn related by self->SM_NSTXN[R507];
   if ( not_empty ns_txn )
     select one seme related by ns_txn->SM_SEME[R504];
     select one orig_state related by seme->SM_STATE[R503];

	 // change SEME caused by old event to be cant happen
	 create object instance ch of SM_CH;
     unrelate ns_txn from seme across R504;
     relate seme to ch across R504;
     
     // find SEME caused by new event
     select any new_seme related by orig_state->SM_SEME[R503] 
         where selected.SMevt_ID == event.SMevt_ID;
     new_seme.disposeChOrEi();
     relate new_seme to ns_txn across R504;
     // state supplemental dataset should be unchanged
   else
     select one cr_txn related by self->SM_CRTXN[R507];
     select one levt related by cr_txn->SM_LEVT[R509];
     if ( not_empty levt )
       unrelate cr_txn from levt across R509;
     end if;
     select one new_evt related by event->SM_SEVT[R525]->SM_LEVT[R526];         
     relate cr_txn to new_evt across R509;
   end if;
 end if;

',
	1,
	'',
	"e3dcfdf1-8a63-4967-be64-ec5061083550");
INSERT INTO O_TPARM
	VALUES ("783fb7b2-fb80-4b1f-a5bf-d9abcfc2b677",
	"7713fe33-c434-4a8e-80d6-d745769cb806",
	'eventId',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("cf7b874c-52ed-4feb-8637-5f2b4ed4a777",
	"7713fe33-c434-4a8e-80d6-d745769cb806",
	'eventStateMachineId',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"783fb7b2-fb80-4b1f-a5bf-d9abcfc2b677",
	'');
INSERT INTO O_TFR
	VALUES ("23d5bb27-aebd-4765-b01e-d09c1e0bd741",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'removeEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one ns_txn related by self->SM_NSTXN[R507];
if ( not_empty ns_txn )
 
  select one seme related by ns_txn->SM_SEME[R504];
  create object instance ch of SM_CH;
  unrelate ns_txn from seme across R504;
  relate seme to ch across R504;

  create object instance ne_txn of SM_NETXN;
  unrelate ns_txn from self across R507;
  relate self to ne_txn across R507;
  delete object instance ns_txn;
  select one orig_state related by seme->SM_STATE[R503];
  relate ne_txn to orig_state across R508;
  select one dest_state related by self->SM_STATE[R506];
else
  select one cr_txn related by self->SM_CRTXN[R507];
  select one levt related by cr_txn->SM_LEVT[R509];
  if ( not_empty levt )
    unrelate cr_txn from levt across R509;
    select one st related by self->SM_STATE[R506];
  else
    // transition doesn''t have an event assigned -- UI prevents this from happening
  end if;
end if;',
	1,
	'',
	"06f1a674-06d5-4ac8-a89f-2f248d44c0c1");
INSERT INTO O_TFR
	VALUES ("9f1bfd7a-2163-4dbc-a10f-b0528e15b137",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'updateAssignedEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Transition.updateAssignedEvent()
select one stateMachine related by self->SM_SM[R505];
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
select one sm related by self->SM_SM[R505];
select one creationTrans related by self->SM_CRTXN[R507];
select any polyClass from instances of O_OBJ where
                                        selected.Obj_ID == GD::NULL_UNIQUE_ID();
isPoly = false;
if(not_empty evt)
  // if the copied event is a poly, convert it to a local event
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nlevt)
    isPoly = true;
  end if;
end if;
creation = false;
if(not_empty creationTrans)
  creation = true;
  select one evt related by creationTrans->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
end if;
// there was no event previously assigned, nothing to do.
if(empty evt)
  return;
end if;
select many dataItems related by evt->SM_EVTDI[R532];
eventID = sm.findMatchingEvent(id:evt.SMevt_ID,
                                       isCreation:creation, machineID:sm.SM_ID);
select any existingEvt related by sm->SM_EVT[R502] where
                                                   selected.SMevt_ID == eventID;
if not_empty existingEvt
  // remove the currently assigned event
  self.removeEvent();
  // if a match was found then
  //   - remove any pasted data items already assigned to the existing event.
  //   - move any new data items to the existing event and
  //   - dispose the pasted event instance.
  warnings = ""; sep = "";
  for each dataItem in dataItems
    select one pastedDIDatatype related by dataItem->S_DT[R524];
    select any existingDataItem related by existingEvt->SM_EVTDI[R532] where
                                                 selected.Name == dataItem.Name;
    select one existingDIDatatype related by existingDataItem->S_DT[R524];
    if not_empty existingDataItem and
                  existingDIDatatype.Name == pastedDIDatatype.Name and
                         OS::remove_spaces(s:existingDataItem.Dimensions) ==
                                        OS::remove_spaces(s:dataItem.Dimensions)
      dataItem.dispose();
    else
      // Report that event parameters were added to the target
      if empty existingDataItem 
        warnings = warnings + sep + "Event parameter " + dataItem.Name +
                                                                   " was added";
      else  // not_empty existingDataItem and
        warnType = "";
        if existingDIDatatype.Name != pastedDIDatatype.Name
          // Report that an added event parameter type conflict exists
          warnType = " a type conflict ";
        else
          // Report that a dimension declaration incompatibility exists
          warnType = " an array incompatibility ";
        end if;
        warnings = warnings + sep + "An existing event parameter " +
        dataItem.Name + " was found, but has" + warnType + "with the pasted " +
        "parameter. The paste has been executed as an additional parameter " +
        "with the same name. You will need to combine the two parameters or " +
        "rename one.";
      end if;
      sep = ", ";
      unrelate dataItem from evt across R532;
      relate dataItem to existingEvt across R532;
      select one pasteSM related by dataItem->SM_SM[R516];
      if not_empty pasteSM
        unrelate dataItem from pasteSM across R516;
      end if;
      relate dataItem to sm across R516;
    end if;
  end for;
  if warnings != ""
    // we must relate the event to the state machine to allow for the
    // get_name operation to work correctly for the error report.
    select one pasteSM related by evt->SM_SM[R502];
    if empty pasteSM
      relate evt to sm across R502;
    end if;
    Util::addPastedElementToProblemList(elementName:evt.get_name(),
      		                                                  message:warnings);
  end if;
  evt.dispose();
  // and now associate the pasted transition with the match
  self.addEvent(eventId:existingEvt.SMevt_ID, eventStateMachineId:sm.SM_ID);
else // existing event was not found in this state machine
  // if the copied event is a polymorphic event and we didn''t find
  // a match above we need to try and find a matching one within
  // the hierarchy
  relateToSM = true;
  if(isPoly)
    polyId = self.locateMatchingPolymorphicEvent(id:evt.SMevt_ID);
    if(polyId != GD::NULL_UNIQUE_ID())
      select any polyEvt from instances of SM_EVT where
                                                    selected.SMevt_ID == polyId;
      if(not_empty polyEvt)
        select one poly related by polyEvt->SM_PEVT[R525];
        if(empty poly)
          // the instance will not exist unless another
          // transition has the poly assigned so we create
          // it here
          create object instance poly of SM_PEVT;
          select one matrixEvent related by polyEvt->SM_SEVT[R525];
          matrixEvent.dispose();
          relate poly to polyEvt across R525;
        end if;
        select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
        relate nlevt to poly across R527;
      else
        evt.dispose();
        relateToSM = false;
      end if;
    else
      // we must relate the event to the state machine to allow for the
      // get_name operation to work correctly for the error report.
      relate evt to sm across R502;
      message = ::getMissingInheritedEventMessage(missingInheritedEvent:false);
      Util::addPastedElementToProblemList(elementName:evt.get_name(),
      		message:message);
      evt.dispose();
      relateToSM = false;
    end if;
  end if;
  if(relateToSM)
    // otherwise hook up the copied event and data items if any
    relate evt to sm across R502;
    for each dataItem in dataItems
      relate dataItem to sm across R516;
    end for;
    select one sevt related by evt->SM_SEVT[R525];
    if not_empty sevt
      // create SEM entry instances
      //
      select many states related by sm->SM_STATE[R501];
      for each state in states
        select any existingEvt related by state->SM_SEME[R503]->
              SM_SEVT[R503]->SM_EVT[R525] where selected.Drv_Lbl == evt.Drv_Lbl;
        if empty existingEvt
          create object instance seme of SM_SEME;
          relate sevt to state across R503 using seme;
        end if;
      end for;
    else
      pathMsg = "<No Path Available - Empty instance>";
    if (not_empty stateMachine)
      pathMsg = stateMachine.getPath();
    end if;
	USER::logError(msg:"Internal Error in updateAssignedEvent:" +
               " No State Event Matrix Event instance found for pasted event.",path:pathMsg);
    end if;
    // guarantee a unique number for the event
    evt.setUniqueNumber(checkForDuplicate:true);
  end if;
end if;',
	1,
	'',
	"7660d40d-57f4-47b1-8275-83e5e6ecf0c6");
INSERT INTO O_TFR
	VALUES ("06f1a674-06d5-4ac8-a89f-2f248d44c0c1",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'locateMatchingPolymorphicEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'/*
Recursively checks the hierarchy tree, to find a polymorpic event that
matches the copied polymorphic event.
*/
select one stateMachine related by self->SM_SM[R505];
select one asm related by self->SM_SM[R505]->SM_ASM[R517];
isClassBased = not_empty asm;
select one mclass related by asm->O_OBJ[R519];
if(empty mclass)
  select one mclass related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
end if;

select one packageableElem related by mclass->PE_PE[R8001];
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];

    select many machines related by package->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]
           ->SM_ASM[R519]->SM_SM[R517];
  if (not_empty machines)
    rootCompIdInPkg = component.getRootComponentId();
    select any rootComponent from instances of C_C where (selected.Id == rootCompIdInPkg);
    select many machines related by rootComponent->PE_PE[R8001]->EP_PKG[R8000]
           ->S_SYS[R1405]->EP_PKG[R1405]->PE_PE[R8000]->O_OBJ[R8001]->SM_ASM[R519]->SM_SM[R517];
  end if;

select many events related by machines->SM_EVT[R502];
select one copiedEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525];
// for all of the possible events see if any match
for each evt in events
  // ignore the copied event
  if(copiedEvt == evt)
    continue;
  end if;
  // do not look for non-local events
  select one nlevt related by evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if(not_empty nlevt)
    continue;
  end if;
  // do not use any event that is within the same machine
  select one sm related by evt->SM_SM[R502];
  if(sm == stateMachine)
    continue;
  end if;
  if(stateMachine.canAssignEvent(eventId:evt.SMevt_ID, eventStateMachineId:evt.SM_ID, isCreationTransition:false))
    eventID = sm.findMatchingEvent(id:copiedEvt.SMevt_ID, isCreation:false, machineID:stateMachine.SM_ID);
    if(eventID != GD::NULL_UNIQUE_ID())
      return eventID;
    end if;
  end if;
end for;
return GD::NULL_UNIQUE_ID();',
	1,
	'',
	"2457d10e-b715-4748-b378-6bc6e0021127");
INSERT INTO O_TPARM
	VALUES ("6784ee7d-cf09-46a3-9074-016d717aeddf",
	"06f1a674-06d5-4ac8-a89f-2f248d44c0c1",
	'id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("11c18895-50c3-4135-bb79-aafdb17e5e4f",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'addSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// find the signal for the passed id

  select one pe related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519]
                                                                 ->PE_PE[R8001];
    select one package related by pe->EP_PKG[R8000];
    // the next call can return a null id, however
    // the UI code will prevent us from ever getting
    // here unless a container component exists
    compId = package.getContainingComponentId();
    select any component from instances of C_C where (selected.Id == compId);

      select any signal related by component->C_PO[R4010]->C_IR[R4016]
               ->C_I[R4012]->C_EP[R4003] where (selected.Id == param.signal_id);


select any reqEP related by signal->SPR_REP[R4500]
                     where (selected.ExecutableProperty_Id == param.signal_id
                             and selected.Requirement_Id == param.interface_id);
select one reqSignal related by reqEP->SPR_RS[R4502];
select any provEP related by signal->SPR_PEP[R4501]
                     where (selected.ExecutableProperty_Id == param.signal_id
                               and selected.Provision_Id == param.interface_id);
select one provSignal related by provEP->SPR_PS[R4503];
select one sm related by self->SM_SM[R505];
select one signalEvent related by provSignal->SM_SGEVT[R528];
if empty signalEvent
  select one signalEvent related by reqSignal->SM_SGEVT[R529];
end if;
if empty signalEvent
  create object instance signalEvent of SM_SGEVT;
  create object instance semEvt of SM_SEVT;
  relate semEvt to signalEvent across R526;
  name = "";
  if not_empty provSignal
    relate signalEvent to provSignal across R528;
    name = provSignal.Name;
  else
    relate signalEvent to reqSignal across R529;
    name = reqSignal.Name;
  end if;
  create object instance evt of SM_EVT;
  relate evt to semEvt across R525;
  relate evt to sm across R502;
  evt.Mning = name;
  evt.Numb = 1;
  evt.setUniqueNumber(checkForDuplicate:false);
  semEvt.createDefaultMatrixEntries();
end if;
select one no_evt_txn related by self->SM_NETXN[R507];
if ( not_empty no_evt_txn )
  select one orig_state related by no_evt_txn->SM_STATE[R508];
  unrelate no_evt_txn from orig_state across R508;
  unrelate no_evt_txn from self across R507;
  delete object instance no_evt_txn;
  create object instance ns_txn of SM_NSTXN;
  relate self to ns_txn across R507;
  select any seme related by orig_state->SM_SEME[R503]
                                where selected.SMevt_ID == signalEvent.SMevt_ID;
  seme.disposeChOrEi();
  relate ns_txn to seme across R504;
else
  select one ns_txn related by self->SM_NSTXN[R507];
  if ( not_empty ns_txn )
    select one seme related by ns_txn->SM_SEME[R504];
    select one orig_state related by seme->SM_STATE[R503];
                             
    // change SEME caused by old event to be cant happen
    create object instance ch of SM_CH;
    unrelate ns_txn from seme across R504;
    relate seme to ch across R504;
                             
    // find SEME caused by new event
    select any new_seme related by orig_state->SM_SEME[R503]
                                where selected.SMevt_ID == signalEvent.SMevt_ID;
    new_seme.disposeChOrEi();
    relate new_seme to ns_txn across R504;
  end if;
end if;',
	1,
	'',
	"7713fe33-c434-4a8e-80d6-d745769cb806");
INSERT INTO O_TPARM
	VALUES ("a4640f25-2002-49dd-897e-f27b76190a9a",
	"11c18895-50c3-4135-bb79-aafdb17e5e4f",
	'signal_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"8e873940-32a0-4a1b-b0a8-1395cf1ff551",
	'');
INSERT INTO O_TPARM
	VALUES ("8e873940-32a0-4a1b-b0a8-1395cf1ff551",
	"11c18895-50c3-4135-bb79-aafdb17e5e4f",
	'interface_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("7660d40d-57f4-47b1-8275-83e5e6ecf0c6",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'removeSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Transition::removeSignal()
select one ns_txn related by self->SM_NSTXN[R507];
if ( not_empty ns_txn )
  select one seme related by ns_txn->SM_SEME[R504];
  create object instance ch of SM_CH;
  unrelate ns_txn from seme across R504;
  relate seme to ch across R504;
  create object instance ne_txn of SM_NETXN;
  unrelate ns_txn from self across R507;
  relate self to ne_txn across R507;
  delete object instance ns_txn;
  select one orig_state related by seme->SM_STATE[R503];
  relate ne_txn to orig_state across R508;
  select one sevt related by seme->SM_SEVT[R503];
  select many chs related by sevt->SM_SEME[R503]->SM_CH[R504];
  select many states related by sevt->SM_STATE[R503];
  if cardinality chs == cardinality states
    // There are no consumers of this signal left, dispose it.
    select one evt related by sevt->SM_EVT[R525];
    evt.dispose();    
  end if;
end if;',
	1,
	'',
	"23d5bb27-aebd-4765-b01e-d09c1e0bd741");
INSERT INTO O_TFR
	VALUES ("2457d10e-b715-4748-b378-6bc6e0021127",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'initialize',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Transition.initialize()
// Create the action home
create object instance ah of SM_AH;
create object instance tah of SM_TAH;
relate ah to tah across R513;
select one sm related by self->SM_SM[R505];  
create object instance act of SM_ACT;
act.Suc_Pars = ParseStatus::parseInitial;
relate act to ah across R514;
relate act to sm across R515;
relate self to tah across R530;
',
	1,
	'',
	"2db70c57-8fdd-4285-ad1a-c8885c3bd09c");
INSERT INTO O_TFR
	VALUES ("a55a875f-15d9-4608-bf6c-62e419288692",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'get_name',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'// Transition.get_name()
result = "";
select one nst related by self->SM_NSTXN[R507];
if not_empty nst
  result = nst.get_name();
end if;
select one net related by self->SM_NETXN[R507];
if not_empty net
  result = net.get_connector_text();
end if;
select one ctxn related by self->SM_CRTXN[R507];
if(not_empty ctxn)
  select one evt related by ctxn->SM_LEVT[R509]->SM_SEVT[R526]
                                                                                              ->SM_EVT[R525];
  if(not_empty evt)
    result = evt.get_event_text();
  else
    result = "No Event Assigned";
  end if;
end if;
return result;',
	1,
	'',
	"8c23089d-4120-4409-ac99-0aa46872aa74");
INSERT INTO O_TFR
	VALUES ("edbb77d5-416c-46d2-9f14-536e53f7109b",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'updateAssignedSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one machine related by self->SM_SM[R505];
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
if(not_empty component)
  select one signalEvt related by evt->SM_SGEVT[R526];
  select one proSignal related by signalEvt->SPR_PS[R528];
  select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
  if(not_empty proSignal and Util::isProxy(element:proSignal.convertToInstance()))
    signalId = self.locateMatchingProvidedSignal();
    select any matchingSignal related by interfaces->C_EP[R4003]
                ->SPR_PEP[R4501]->SPR_PS[R4503] where (selected.Id == signalId);
    if(not_empty matchingSignal)
      self.removeSignal();
      select one pep related by matchingSignal->SPR_PEP[R4503];
      self.addSignal(interface_id: pep.Provision_Id,
                                          signal_id: pep.ExecutableProperty_Id);
    else
      // look for a matching required signal
      signalId = self.locateMatchingRequiredSignal();
      select any matchingReqSignal related by interfaces->C_EP[R4003]
                ->SPR_REP[R4500]->SPR_RS[R4502] where (selected.Id == signalId);
      if(not_empty matchingReqSignal)
        self.removeSignal();
        select one rep related by matchingReqSignal->SPR_REP[R4502];
        self.addSignal(interface_id: rep.Requirement_Id,
                                          signal_id: rep.ExecutableProperty_Id);
      else
        // indicate to the user that no matching signal was
        // found in the destination
        message = "Matching signals for the following were not found in the ";
        message = message + "destination.";
        Util::addPastedElementToProblemList(
                      elementName:signalEvt.get_event_text(), message: message);
        self.removeSignal();
      end if;
    end if;
  end if;
  select one reqSignal related by signalEvt->SPR_RS[R529];
  if(not_empty reqSignal and Util::isProxy(element:reqSignal.convertToInstance()))
    signalId = self.locateMatchingRequiredSignal();
    select any matchingSignal related by interfaces->C_EP[R4003]
                ->SPR_REP[R4500]->SPR_RS[R4502] where (selected.Id == signalId);
    if(not_empty matchingSignal)
      self.removeSignal();
      select one rep related by matchingSignal->SPR_REP[R4502];
      self.addSignal(interface_id: rep.Requirement_Id,
                                          signal_id: rep.ExecutableProperty_Id);
    else
      // look for a matching provided signal
      signalId = self.locateMatchingProvidedSignal();
      select any matchingProSignal related by interfaces->C_EP[R4003]
                ->SPR_PEP[R4501]->SPR_PS[R4503] where (selected.Id == signalId);
      if(not_empty matchingProSignal)
        self.removeSignal();
        select one pep related by matchingProSignal->SPR_PEP[R4503];
        self.addSignal(interface_id: pep.Provision_Id,
                                          signal_id: pep.ExecutableProperty_Id);
      else
        // indicate to the user that no matching signal was
        // found in the destination
        message = "Matching signals for the following were not found in the ";
        message = message + "destination.";
        Util::addPastedElementToProblemList(
                      elementName:signalEvt.get_event_text(), message: message);
        self.removeSignal();
      end if;
    end if;
  end if;
end if;',
	1,
	'',
	"9f1bfd7a-2163-4dbc-a10f-b0528e15b137");
INSERT INTO O_TFR
	VALUES ("476dfb01-e357-40f0-a5b2-ec0da1c99424",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'updateAssignedEventOrSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one creationTrans related by self->SM_CRTXN[R507];
if(not_empty creationTrans)
  self.updateAssignedEvent();
  return;
end if;
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
if(not_empty evt)
  select one signalEvent related by evt->SM_SGEVT[R526];
  if(not_empty signalEvent)
    self.updateAssignedSignal();
  else
    self.updateAssignedEvent();
  end if;
end if;',
	1,
	'',
	"edbb77d5-416c-46d2-9f14-536e53f7109b");
INSERT INTO O_TFR
	VALUES ("7adf02b5-819b-4ac9-86f1-a209b8fb2d2d",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'locateMatchingProvidedSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'select one stateMachine related by self->SM_SM[R505];
select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one signalEvt related by evt->SM_SGEVT[R526];
select one proSignal related by signalEvt->SPR_PS[R528];

name = "";
direction = IFDirectionType::ClientServer;
select any ep from instances of C_EP
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
if(not_empty proSignal)
  name = proSignal.Name;
  select one ep related by proSignal->SPR_PEP[R4503]->C_EP[R4501];
  select one sig related by ep->C_AS[R4004];
  direction = sig.Direction;
else
  select one reqSignal related by signalEvt->SPR_RS[R529];
  if(not_empty reqSignal)
    name = reqSignal.Name;
    direction = IFDirectionType::ClientServer;
    select one ep related by reqSignal->SPR_REP[R4502]->C_EP[R4500];
  else
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty stateMachine)
      pathMsg = stateMachine.getPath();
    end if;
	USER::logError(msg:"Signal Event had no associated signal.",path:pathMsg);
    return GD::NULL_UNIQUE_ID();
  end if;
end if;
select one machine related by self->SM_SM[R505];
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
select many testParameters related by ep->C_PP[R4006];
select any matchingSignal from instances of SPR_PS
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
select many existingProSignals related by interfaces->C_EP[R4003]
                                                ->SPR_PEP[R4501]->SPR_PS[R4503];
for each existingSignal in existingProSignals
  select one existingAS related by existingSignal->SPR_PEP[R4503]->C_EP[R4501]
                                                                  ->C_AS[R4004];
  if(existingSignal.Name == name and existingAS.Direction == direction)
    select many parameters related by existingSignal->SPR_PEP[R4503]
                                                     ->C_EP[R4501]->C_PP[R4006];
    index = 0;
    matchNotFound = false; 
    for each testParm in testParameters
      internalIndex = 0;
      select one testType related by testParm->S_DT[R4007];
      for each parameter in parameters
        if(internalIndex == index)
          // param to test
          if(testParm.Name != parameter.Name)
            matchNotFound = true;
            break;
          end if;
          select one type related by parameter->S_DT[R4007];
          if(testType.Name != type.Name)
            matchNotFound = true;
            break;
          end if;
        end if;
        internalIndex = internalIndex + 1;
      end for;
      if(matchNotFound)
        break;
      end if;
      index = index + 1;
      if(cardinality parameters < cardinality testParameters)
        // this is not OK, the existing signal will not satisfy
        // the copied signal
        matchNotFound = true;
        break;
      end if;
    end for;
    if(not matchNotFound)
      // ask the signal if it can be allocated to this
      // transition
      if(existingSignal.isAvailableForAllocationTo(transition_id:self.Trans_ID))
        matchingSignal = existingSignal;
        break;
      end if;
    end if;
  end if;
end for;
if(not_empty matchingSignal)
  return matchingSignal.Id;
else
  return GD::NULL_UNIQUE_ID();
end if;',
	1,
	'',
	"476dfb01-e357-40f0-a5b2-ec0da1c99424");
INSERT INTO O_TFR
	VALUES ("e3573d1b-21e9-46e3-9f3a-10f52467ab10",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'locateMatchingRequiredSignal',
	'',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'select one evt related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503];
select one signalEvt related by evt->SM_SGEVT[R526];
select one reqSignal related by signalEvt->SPR_RS[R529];
select one machine related by self->SM_SM[R505];
name = "";
direction = IFDirectionType::ServerClient;
select any ep from instances of C_EP
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
if(not_empty reqSignal)
  name = reqSignal.Name;
  select one ep related by reqSignal->SPR_REP[R4502]->C_EP[R4500];
  select one sig related by ep->C_AS[R4004];
  direction = sig.Direction;
else
  select one proSignal related by signalEvt->SPR_PS[R528];
  if(not_empty proSignal)
    name = proSignal.Name;
    direction = IFDirectionType::ServerClient;
    select one ep related by proSignal->SPR_PEP[R4503]->C_EP[R4501];
  else
    pathMsg = "<No Path Available - Empty instance>";
    if (not_empty machine)
      pathMsg = machine.getPath();
    end if;
	USER::logError(msg:"Signal Event had no associated signal.",path:pathMsg);
    return GD::NULL_UNIQUE_ID();
  end if;
end if;
// note the selection from instances of will work below as we are contained in
// the same model root as the component
componentId = machine.getContainingComponentId();
select any component from instances of C_C where (selected.Id == componentId);
select many interfaces related by component->C_PO[R4010]->C_IR[R4016]
                                                                   ->C_I[R4012];
select many testParameters related by ep->C_PP[R4006];
select any matchingSignal from instances of SPR_RS
                                    where (selected.Id == GD::NULL_UNIQUE_ID());
select many existingReqSignals related by interfaces->C_EP[R4003]
                                                ->SPR_REP[R4500]->SPR_RS[R4502];
for each existingSignal in existingReqSignals
  select one existingSigAS related by existingSignal->SPR_REP[R4502]
                                                     ->C_EP[R4500]->C_AS[R4004];
  if(existingSignal.Name == name and existingSigAS.Direction == direction)
    select many parameters related by existingSignal->SPR_REP[R4502]
                                                     ->C_EP[R4500]->C_PP[R4006];
    index = 0;
    matchNotFound = false;
    for each testParm in testParameters
      internalIndex = 0;
      select one testType related by testParm->S_DT[R4007];
      for each parameter in parameters
        if(internalIndex == index)
          // param to test
          if(testParm.Name != parameter.Name)
            matchNotFound = true;
            break;
          end if;
          select one type related by parameter->S_DT[R4007];
          if(testType.Name != type.Name)
            matchNotFound = true;
            break;
          end if;
        end if;
        internalIndex = internalIndex + 1;
      end for;
      if(matchNotFound)
        break;
      end if;
      index = index + 1;
      if(cardinality parameters < cardinality testParameters)
        // this is not OK, the existing signal will not satisfy
        // the copied signal
        matchNotFound = true;
        break;
      end if;
    end for;
    if(not matchNotFound)
      // ask the signal if it can be allocated to this
      // transition
      if(existingSignal.isAvailableForAllocationTo(transition_id:self.Trans_ID))
        matchingSignal = existingSignal;
        break;
      end if;
    end if;
  end if;
end for;
if(not_empty matchingSignal)
  return matchingSignal.Id;
else
  return GD::NULL_UNIQUE_ID();
end if; ',
	1,
	'',
	"7adf02b5-819b-4ac9-86f1-a209b8fb2d2d");
INSERT INTO O_TFR
	VALUES ("a64e45ad-2723-4a3b-9041-583793869a45",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'get_label',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'// Transition.get_name()
result = "";
select one nst related by self->SM_NSTXN[R507];
if not_empty nst
  result = nst.get_name();
end if;
select one net related by self->SM_NETXN[R507];
if not_empty net
  result = net.get_connector_text();
end if;
select one destState related by self->SM_STATE[R506];
select one srcState related by nst->SM_SEME[R504]->SM_STATE[R503];
if not_empty srcState
  result = srcState.Name + "::" + result;
end if;
return result;',
	1,
	'',
	"e3573d1b-21e9-46e3-9f3a-10f52467ab10");
INSERT INTO O_TFR
	VALUES ("3db072d3-a0de-497d-9523-994ead42b8d1",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'mergeDispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'select one nstxn related by self->SM_NSTXN[R507];
if (not_empty nstxn)
  unrelate nstxn from self across R507;
  select one seme related by nstxn->SM_SEME[R504];
  if(not_empty seme)
    unrelate nstxn from seme across R504;
  end if;
  delete object instance nstxn;
end if;
                                   
select one crtxn related by self->SM_CRTXN[R507];
if (not_empty crtxn)
  unrelate self from crtxn across R507;
  select one evt related by crtxn->SM_LEVT[R509];
  if(not_empty evt)
    unrelate evt from crtxn across R509;
  end if;
  delete object instance crtxn;
end if; 
select one netxn related by self->SM_NETXN[R507];
if (not_empty netxn)
  unrelate self from netxn across R507;
  select one state related by netxn->SM_STATE[R508];
  unrelate netxn from state across R508;
  delete object instance netxn;
end if;
                                   
select one sm related by self->SM_SM[R505];
unrelate self from sm across R505;
select one state related by self->SM_STATE[R506];
unrelate self from state across R506;
select one act related by self->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
if (not_empty act )
  act.dispose();
else
  // the dispose unit tests don''t populate everything
  select one meah related by self->SM_MEAH[R512];
  if ( not_empty meah )
    select one mealy related by meah->SM_MEALY[R512];
    unrelate mealy from self across R512 using meah;
  end if;
end if;
select many insts related by self->I_INS[R2953];
for each inst in insts
  unrelate self from inst across R2953;
end for;
select many classInStates related by self->CSME_CIS[R2952];
for each classInState in classInStates
  classInState.dispose();
end for;
delete object instance self;',
	1,
	'',
	"a64e45ad-2723-4a3b-9041-583793869a45");
INSERT INTO O_TFR
	VALUES ("b8ffb26a-726e-4fe3-876d-56ea4ecdc48c",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'checkIntegrity',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'/**
 *  Create an integrity issue if any other transition a the same source state 
 *  and shares the same assigned event
 */
select one class related by self->SM_SM[R505]->SM_ISM[R517]->O_OBJ[R518];
select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
machineName = "Instance State Machine";
if(empty package)
  select one class related by self->SM_SM[R505]->SM_ASM[R517]->O_OBJ[R519];
  select one package related by class->PE_PE[R8001]->EP_PKG[R8000];
  machineName = "Class State Machine";
end if;
select one state related by self->SM_NSTXN[R507]->SM_SEME[R504]->SM_STATE[R503];
select many transitions related by state->SM_SEME[R503]
                                                 ->SM_NSTXN[R504]->SM_TXN[R507];
for each transition in transitions
  select one selfEvt related by self->SM_NSTXN[R507]->SM_SEME[R504]
                                                                ->SM_SEVT[R503];
  select one otherEvt related by transition->SM_NSTXN[R507]->SM_SEME[R504]
                                                                ->SM_SEVT[R503];                                                                
  if(transition != self and otherEvt == selfEvt)
    select one system related by package->S_SYS[R1405];
    sys_id = GD::NULL_UNIQUE_ID();
    if(not_empty system)
      sys_id = system.Sys_ID;
    end if;
	MI_IM::createIssue(sys_id:sys_id, description:
	               "Found another transition with the same event assignment " +
  "leaving the same state.", severity:Severity::Error, name:self.get_name(),
	                path:class.getPath(path:self.get_name(), includeSelf:true) +
	              "::" + machineName + "::" + self.get_name(), id:self.SMstt_ID,
	                                          element:self.convertToInstance());
  end if;
end for;',
	1,
	'',
	"3db072d3-a0de-497d-9523-994ead42b8d1");
INSERT INTO O_TFR
	VALUES ("6ecc4eaf-36ca-4838-84c9-5e5df6f82019",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'convertToInstance',
	'A utility operation to cast an instance of this type to the
instance datatype.

Translate: native',
	"a5d8b590-a627-4af4-afdf-152c889769b6",
	1,
	'// just return this instance as an Object
return this;',
	0,
	'',
	"b8ffb26a-726e-4fe3-876d-56ea4ecdc48c");
INSERT INTO S_DT_PROXY
	VALUES ("a5d8b590-a627-4af4-afdf-152c889769b6",
	"00000000-0000-0000-0000-000000000000",
	'instance',
	'',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO O_TFR
	VALUES ("bbc99347-3a9c-42b4-bbed-ae7bbda2f26a",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'mergeStateMachineEventAssignedLocalEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'// only process this if it is a removal, which the given UUID will be null
if(param.event_id == GD::NULL_UNIQUE_ID())
  select one ns_txn related by self->SM_NSTXN[R507];
  if ( not_empty ns_txn )
    select one seme related by ns_txn->SM_SEME[R504];
    select one event related by seme->SM_SEVT[R503];
    select one state related by seme->SM_STATE[R503];
    select many existing related by event->SM_SEME[R503]
                                 where (selected.SMevt_ID == event.SMevt_ID and
                                           selected.SMstt_ID == state.SMstt_ID);
    if(cardinality existing == 1)
      create object instance ch of SM_CH;
      relate seme to ch across R504;
    end if;
    unrelate ns_txn from seme across R504;
    create object instance ne_txn of SM_NETXN;
    unrelate ns_txn from self across R507;
    relate self to ne_txn across R507;
    delete object instance ns_txn;
    select one orig_state related by seme->SM_STATE[R503];
    relate ne_txn to orig_state across R508;
    select one dest_state related by self->SM_STATE[R506];
  else
    select one cr_txn related by self->SM_CRTXN[R507];
    select one levt related by cr_txn->SM_LEVT[R509];
    if ( not_empty levt )
      unrelate cr_txn from levt across R509;
    end if;
  end if;
  return true;
end if;
return false;',
	1,
	'',
	"6ecc4eaf-36ca-4838-84c9-5e5df6f82019");
INSERT INTO O_TPARM
	VALUES ("29052f7b-ded3-4a9b-9790-a56919b10e62",
	"bbc99347-3a9c-42b4-bbed-ae7bbda2f26a",
	'event_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("4e626c37-6bfd-4cb4-ada0-6514835914f1",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	'getDescription',
	'',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'select one action related by self->SM_TAH[R530]->SM_AH[R513]
                                                                 ->SM_ACT[R514];
return action.Descrip;',
	1,
	'',
	"bbc99347-3a9c-42b4-bbed-ae7bbda2f26a");
INSERT INTO O_NBATTR
	VALUES ("e3ca4e53-1fca-4541-95f0-736cbff77e75",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582");
INSERT INTO O_BATTR
	VALUES ("e3ca4e53-1fca-4541-95f0-736cbff77e75",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582");
INSERT INTO O_ATTR
	VALUES ("e3ca4e53-1fca-4541-95f0-736cbff77e75",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"00000000-0000-0000-0000-000000000000",
	'Trans_ID',
	'Full Name: Transition Identifier',
	'',
	'Trans_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000005",
	'',
	'');
INSERT INTO O_REF
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"a1150e32-8c3e-4e21-8295-75b0c795b02d",
	0,
	"918c8926-3597-4f97-bdc4-a65cf9de1666",
	"b15c381a-87a7-42ff-8716-39a9b68bdf2c",
	"fc24b895-a489-4ec2-82aa-2d813fa4a583",
	"9cef1f3b-9342-4088-819b-982a6988debd",
	"ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	"87cdfec1-ba72-4445-9837-087e19a08b30",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'State Machine',
	'SM_ID',
	'R505');
INSERT INTO R_RGO_PROXY
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"b15c381a-87a7-42ff-8716-39a9b68bdf2c",
	"fc24b895-a489-4ec2-82aa-2d813fa4a583",
	'../State Machine.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("918c8926-3597-4f97-bdc4-a65cf9de1666",
	"a1150e32-8c3e-4e21-8295-75b0c795b02d",
	0,
	"b15c381a-87a7-42ff-8716-39a9b68bdf2c",
	"9cef1f3b-9342-4088-819b-982a6988debd",
	'../State Machine.xtuml');
INSERT INTO O_REF
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"769395a9-378f-4c72-9fb6-a4b14f155ff3",
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"94fe747d-147b-4916-b231-8872f700e22f",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	"ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	"305d4984-684a-444f-a9be-6d1aa89f48c9",
	"87cdfec1-ba72-4445-9837-087e19a08b30",
	0,
	'',
	'State Machine State',
	'SM_ID',
	'R506.''is destined to''');
INSERT INTO R_RGO_PROXY
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"94fe747d-147b-4916-b231-8872f700e22f",
	'../State Machine.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("769395a9-378f-4c72-9fb6-a4b14f155ff3",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	'../State Machine.xtuml');
INSERT INTO O_RATTR
	VALUES ("ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"918c8926-3597-4f97-bdc4-a65cf9de1666",
	"a1150e32-8c3e-4e21-8295-75b0c795b02d",
	1,
	'SM_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("918c8926-3597-4f97-bdc4-a65cf9de1666",
	"a1150e32-8c3e-4e21-8295-75b0c795b02d",
	'../State Machine/State Machine.xtuml');
INSERT INTO O_ATTR
	VALUES ("ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"e3ca4e53-1fca-4541-95f0-736cbff77e75",
	'SM_ID',
	'',
	'',
	'SM_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_REF
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"5f53a782-ac02-423a-afd2-43e90959c0d4",
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"94fe747d-147b-4916-b231-8872f700e22f",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	"acb5b685-e89f-4b63-9fd3-fcb555788425",
	"ec40aee6-902c-4198-8551-280259551b14",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'State Machine State',
	'SMstt_ID',
	'R506.''is destined to''');
INSERT INTO O_RTIDA_PROXY
	VALUES ("5f53a782-ac02-423a-afd2-43e90959c0d4",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	'../State Machine.xtuml');
INSERT INTO O_RATTR
	VALUES ("acb5b685-e89f-4b63-9fd3-fcb555788425",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"5f53a782-ac02-423a-afd2-43e90959c0d4",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	'SMstt_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("5f53a782-ac02-423a-afd2-43e90959c0d4",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	'../State Machine State/State Machine State.xtuml');
INSERT INTO O_ATTR
	VALUES ("acb5b685-e89f-4b63-9fd3-fcb555788425",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	'SMstt_ID',
	'',
	'',
	'SMstt_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_REF
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"924f3841-dd03-41b4-8c58-21f46c69c91e",
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"94fe747d-147b-4916-b231-8872f700e22f",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	"0f91e8ee-840b-42af-baf8-30c075f045ae",
	"5eba86e9-7536-447f-affa-7c2ca5a3c60b",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'State Machine State',
	'SMspd_ID',
	'R506.''is destined to''');
INSERT INTO O_RTIDA_PROXY
	VALUES ("924f3841-dd03-41b4-8c58-21f46c69c91e",
	"057bc1d4-d11a-40fe-bfb9-e1bd7658f24d",
	1,
	"9805ff8b-3df2-482e-bdc3-17000ab97bbd",
	"fbfdf4fe-9b5f-4034-836e-d50934a286ee",
	'../State Machine.xtuml');
INSERT INTO O_RATTR
	VALUES ("0f91e8ee-840b-42af-baf8-30c075f045ae",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"687f0a3c-0ce1-40b3-a498-b18d64de5cc5",
	"c7bef657-8c46-4a09-b499-e99eb1f234d4",
	1,
	'SMspd_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("687f0a3c-0ce1-40b3-a498-b18d64de5cc5",
	"c7bef657-8c46-4a09-b499-e99eb1f234d4",
	'../Event Supplemental Data/Event Supplemental Data.xtuml');
INSERT INTO O_ATTR
	VALUES ("0f91e8ee-840b-42af-baf8-30c075f045ae",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	"acb5b685-e89f-4b63-9fd3-fcb555788425",
	'SMspd_ID',
	'',
	'',
	'SMspd_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	"cb0e282d-74c6-4f86-8256-4bc5b089a582");
INSERT INTO O_OIDA
	VALUES ("e3ca4e53-1fca-4541-95f0-736cbff77e75",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	0,
	'Trans_ID');
INSERT INTO O_OIDA
	VALUES ("ea0fba5a-5570-412e-8222-0c9ed1e969a9",
	"cb0e282d-74c6-4f86-8256-4bc5b089a582",
	0,
	'SM_ID');
INSERT INTO O_ID
	VALUES (1,
	"cb0e282d-74c6-4f86-8256-4bc5b089a582");
INSERT INTO O_ID
	VALUES (2,
	"cb0e282d-74c6-4f86-8256-4bc5b089a582");
INSERT INTO PE_PE
	VALUES ("cb0e282d-74c6-4f86-8256-4bc5b089a582",
	1,
	"3314c083-3e42-4dfd-8a60-9305d01957ef",
	"00000000-0000-0000-0000-000000000000",
	4);
INSERT INTO EP_PKG_PROXY
	VALUES ("3314c083-3e42-4dfd-8a60-9305d01957ef",
	"00000000-0000-0000-0000-000000000000",
	"2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'State Machine',
	'Classes (O_OBJ) that have interesting behavior are given lifecycles. These lifecycles are described using state machines (SM_SM). A state machine consists of states, events, transitions and state actions. The state machine exists for each instance of the class for which it has been modeled (SM_ISM). A state machine can also be an assigner state machine (SM_ASM) of which only one can exists for all class instances. The purpose of the assigner state machine is to act as a single point of control through which competing requests are serialized.',
	501,
	'../State Machine.xtuml');
