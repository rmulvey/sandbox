-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	"2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'OAL Validation Utility Functions',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("7d19a4ef-0b5b-4833-8266-31b1dc8e1edb",
	112,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'',
	'ooaofooa::ooaofooa::Functions::OAL Validation Utility Functions');
INSERT INTO DIM_DIA
	VALUES ("7d19a4ef-0b5b-4833-8266-31b1dc8e1edb",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("e784b8d1-5682-4a14-b703-d545aea9a441",
	"00000000-0000-0000-0000-000000000000",
	'binary_operation_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any comp_val from instances of V_VAL where ( selected.Value_ID == param.a2_operator );
  if ( empty comp_val  )
    ERR::reportParseError( msg: "Operator not found for " + param.a4_op_type,
        token: param.a6_rule_token );
  else
    select any lhs_val from instances of V_VAL where ( selected.Value_ID == param.a1_left_op );
    select any rhs_val from instances of V_VAL where ( selected.Value_ID == param.a3_right_op );
    if ( empty lhs_val  )
      if ( not_empty rhs_val )
        rhs_val.dispose();
      end if;
      comp_val.dispose();
       ERR::reportParseError( msg: "Left hand operand not found for " + param.a4_op_type,
          token: param.a6_rule_token );
    else
      if ( empty rhs_val  )
        lhs_val.dispose();
        comp_val.dispose();
        ERR::reportParseError( msg: "Right hand operand not found for " + param.a4_op_type,
            token: param.a6_rule_token );
      else
         if lhs_val.getDimensions() < 0
        	ERR::reportParseError(msg:"The rvalue has incompatible array depth", 
                                                   token: param.a6_rule_token ); 
        elif rhs_val.getDimensions() < 0
        
          ERR::reportParseError(msg:"The rvalue has incompatible array depth", 
                                                   token: param.a6_rule_token );
        
        elif rhs_val.getDimensions() != lhs_val.getDimensions()
          ERR::reportParseError(msg:"Incompatible array depth for the oprands", 
                                                   token: param.a6_rule_token );
        end if;
        select one lhs_val_dt related by lhs_val->S_DT[R820];
        if ( empty lhs_val_dt )
         comp_val.dispose();
         ERR::reportParseError( msg: "Left hand operand for " + param.a4_op_type + " has unknown data type.",
            token: param.a6_rule_token );
        else
          select one rhs_val_dt related by rhs_val->S_DT[R820];
          if ( empty rhs_val_dt )
           comp_val.dispose();
           ERR::reportParseError( msg: "Right hand operand for " + param.a4_op_type + " has unknown data type.",
              token: param.a6_rule_token );
          else
            select one bin related by comp_val->V_BIN[R801];
            if ( empty bin )
              ERR::reportParseError( msg: "Cannot find Binary Operator subtype",
                   token: param.a6_rule_token );
            else
              op_dt_id =  ::data_types_compatible( dt1:lhs_val_dt.DT_ID, dt2: rhs_val_dt.DT_ID,
                   op: bin.Operator );
              if (  op_dt_id == GD::NULL_UNIQUE_ID() )
                // must clear garbage before reporting error, reportParseError wont return
                comp_val.dispose();
                lhs_val.dispose();
                rhs_val.dispose();

                ERR::reportParseError( msg: "Incompatible operands for " + param.a4_op_type,
                  token: param.a6_rule_token );
              else
                relate bin to lhs_val across R802;
                relate bin to rhs_val across R803;
                if ( param.a5_set_dt )
                  if ( op_dt_id == lhs_val_dt.DT_ID )
                    relate comp_val to lhs_val_dt across R820;
                  else
                    relate comp_val to rhs_val_dt across R820;
                  end if;
                end if;
                return bin.Value_ID;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;

  return param.a7_rule_id;



',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3866e9ff-5d7a-4071-8b7e-a21f2df1b948",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a1_left_op',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("4b965144-3e46-4487-9812-538009ee8fce",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a2_operator',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"3866e9ff-5d7a-4071-8b7e-a21f2df1b948",
	'');
INSERT INTO S_SPARM
	VALUES ("bf2a1cad-78ac-44d4-bb40-021d0e7a0e00",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a3_right_op',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"4b965144-3e46-4487-9812-538009ee8fce",
	'');
INSERT INTO S_SPARM
	VALUES ("c4876d82-a615-46e6-b13c-bdb34a9a526d",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a4_op_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bf2a1cad-78ac-44d4-bb40-021d0e7a0e00",
	'');
INSERT INTO S_SPARM
	VALUES ("b4e02757-ee21-46c5-b2f4-bc319ff47700",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a5_set_dt',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"c4876d82-a615-46e6-b13c-bdb34a9a526d",
	'');
INSERT INTO S_SPARM
	VALUES ("9688e4fe-11a1-4958-8a1b-9d69c5307c78",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a6_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"b4e02757-ee21-46c5-b2f4-bc319ff47700",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("79308373-d912-4604-b1f4-c457977e3bd2",
	"00000000-0000-0000-0000-000000000000",
	'Token',
	'Each node in the syntax tree has a token associated with it.
We define the type here so that we can pass this data to the 
verification functions, which then pass it on to error reporting 
function, if the verification fails.
Bridge:ALS',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO S_SPARM
	VALUES ("85329229-b544-4283-9367-be0c8fb7a78d",
	"e784b8d1-5682-4a14-b703-d545aea9a441",
	'a7_rule_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"9688e4fe-11a1-4958-8a1b-9d69c5307c78",
	'');
INSERT INTO PE_PE
	VALUES ("e784b8d1-5682-4a14-b703-d545aea9a441",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("974587d0-53a6-48b2-92dc-b76283f1a904",
	"00000000-0000-0000-0000-000000000000",
	'data_types_compatible',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// Try to locate the datatypes in the domain-level datatype package(s)
current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage 
  containerId = ::getValidationDomain();
  select any package from instances of EP_PKG where
                                             selected.Package_ID == containerId;
  select any comp from instances of C_C where selected.Id == containerId;
  if not_empty package
    package.collectVisibleElementsForName(name:"",
         type:ElementTypeConstants::DATATYPE, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  else
    comp.collectVisibleElementsForName(name:"",
         type:ElementTypeConstants::DATATYPE,
                          originatingContainerID:comp.Id,
                                    delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                          collectGlobally:true);
  end if;
  select any resultSet related by package->PE_SRS[R8005] where
        selected.Name == "" and selected.Type == ElementTypeConstants::DATATYPE; 
  select any dt1_dt related by resultSet->PE_VIS[R8006]->
                    PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.dt1;
  select any dt2_dt related by resultSet->PE_VIS[R8006]->
                    PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == param.dt2;
  if not_empty comp
    select any dt1_dt related by comp->PE_CVS[R8004]->
                    PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.dt1;
    select any dt2_dt related by comp->PE_CVS[R8004]->
                    PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == param.dt2;
  end if;
  if empty dt1_dt
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
    return GD::NULL_UNIQUE_ID();
  end if;
  if empty dt2_dt
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt2_dt> is empty.",path:"PathNotProvided");
    return GD::NULL_UNIQUE_ID();
  end if;

  // Set up some flags to be used in the type-equality checks
  foundCDTLHS = false;
  foundCDTRHS = false;
  areCompatible = false;

  // If it''s a UDT, perform compatability tests on the underlying core type
  select one udt1 related by dt1_dt->S_UDT[R17];
  if ( not_empty udt1 )
    foundCDTLHS = true;
    coreId = udt1.getCoreType();
    select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
    select one dt1_dt related by corePE->S_DT[R8001];
  end if;
  select one udt2 related by dt2_dt->S_UDT[R17];
  if ( not_empty udt2 )
    foundCDTRHS = true;
    coreId = udt2.getCoreType();
    select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
    select one dt2_dt related by corePE->S_DT[R8001];
  end if;

  // Check if either is a CDT
  select one cdt1 related by dt1_dt->S_CDT[R17];
  if ( not_empty cdt1 )
    foundCDTLHS = true;
  end if;
  select one cdt2 related by dt2_dt->S_CDT[R17];
  if ( not_empty cdt2 )
    foundCDTRHS = true;
  end if;

  select one irdt1 related by dt1_dt->S_IRDT[R17];

  dt1_is_ir = not_empty irdt1 and not irdt1.isSet;
  dt1_is_irs = not_empty irdt1 and irdt1.isSet;

  select one irdt2 related by dt2_dt->S_IRDT[R17];
  dt2_is_ir = not_empty irdt2 and not irdt2.isSet;
  dt2_is_irs = not_empty irdt2 and irdt2.isSet;

  /**
   *  If both types are not IRDTs then they are incompatible, with
   *  one exception inst_ref<Object>
   */
  if(dt1_is_ir and (not dt2_is_ir and not ::has_substring(p1_base: dt2_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  if(dt1_is_irs and (not dt2_is_irs and not ::has_substring(p1_base: dt2_dt.Name,
                              p2_str: "inst_ref_set<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  /**
   *  Check the opposite, where dt1 is inst_ref<Object> and dt2 is IRDT
   */
  if((not dt1_is_ir and not ::has_substring(p1_base: dt1_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0))
                                  and dt2_is_ir)
    return GD::NULL_UNIQUE_ID();                                  
  end if;

  if((not dt1_is_irs and not ::has_substring(p1_base: dt1_dt.Name,
                                p2_str: "inst_ref_set<Object", p3_fromIndex: 0))
                                and dt2_is_irs)
    return GD::NULL_UNIQUE_ID();
  end if;

  if(not dt1_is_ir)
    // check for special case inst_refs
    dt1_is_ir = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0);
  end if;

  if(not dt1_is_irs)
    // check for special case inst_ref_sets
    dt1_is_irs = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0);  
  end if;

  if ( foundCDTLHS and foundCDTRHS )
    if ( dt1_dt.Name == dt2_dt.Name )
      areCompatible = true;
    end if;
  else
    if ( dt1_dt.DT_ID == dt2_dt.DT_ID )
      areCompatible = true;
    end if;
  end if;

  if ( areCompatible )
    // only check for disallowed operations, since they are fewer
    if ( (not dt1_is_ir and not dt1_is_irs and dt1_dt.Name != "boolean") and
        (param.op == "and" or param.op == "or")  )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "boolean" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "string" and
       ( param.op == "-" or param.op == "*" or param.op == "/" or param.op == "%") )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "unique_id" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "*" or param.op == "/" or param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "and" or param.op == "or" or param.op == "+"  or
         param.op == "-" ) )
      return_type = param.dt1;
      if ( dt1_is_ir )
        // The result of an operation on two inst_ref''s is an inst_ref_set.  So,
        // locate the appropriate inst_ref_set, or error if it doesn''t exist.
        select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
        select any irsdt related by irdt1_obj->S_IRDT[R123] where selected.isSet == true;
        if ( empty irsdt )
          // TODO - it would be nice to report a meaningful parse error here.
          // However, we don''t have a token to pass to the error reporting function.
          // Also, the error reporting function does not return, so not sure how that
          // affects downstream code that uses the return value.
          return_type = GD::NULL_UNIQUE_ID();
        else
          return_type = irsdt.DT_ID;
        end if;
      end if;
      return return_type;
    else
      return param.dt1;
    end if;
  else
    //   The following truth table represents the logic of this inst_ref checking
    //   block.  Any other operations on mixed inst_ref and inst_ref_set are
    //   invalid.  Also, the referenced class must match (i.e. you can''t perform
    //   an operation such as inst_ref<foo> + inst_ref<bar>).
    //
    //      left               right
    //      type           op  type             return
    //      -------------  --  --------------   ------
    //      <inst_ref>      |  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      &  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      +  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      -  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref_set>  |  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  &  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  +  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  -  <inst_ref>       <inst_ref_set>
    if ( dt1_is_ir or dt1_is_irs )
      if ( param.op != "and" and param.op != "or" and param.op != "+" and
         param.op != "-" )
        return GD::NULL_UNIQUE_ID();
      end if;

      // Now that we''ve established we''re using a valid operator, check that the
      // reference and set are for the same class
      select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
      select one irdt2_obj related by dt2_dt->S_IRDT[R17]->O_OBJ[R123];

      if empty irdt1_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt1_obj> is empty.",path:"PathNotProvided");
      end if;
      if empty irdt2_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt2_obj> is empty.",path:"PathNotProvided");
      end if;

      if ( irdt1_obj.Obj_ID != irdt2_obj.Obj_ID )
        return GD::NULL_UNIQUE_ID();
      end if;

      // We''ve passed all the checks, so return the set datatype
      if ( dt1_is_irs )
        return param.dt1;
      else
        return param.dt2;
      end if;
    end if;

    // Disallow boolean operations of non-matching data types
    if ( param.op == "and" or param.op == "or" )
      return GD::NULL_UNIQUE_ID();
    end if;

    //
    // The follow truth table represents the logic this block implements.
    // Operator "=" means assignment, operator "+" means all other operators.
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           T           i
    //      i       r       =           F           T           bad
    //      i       r       =           F           F           bad
    //      i       r       +           T           T           r
    //      i       r       +           F           T           r
    //      i       r       +           F           F           bad
    //      r       i       =           T           T           r
    //      r       i       =           F           T           r
    //      r       i       =           F           F           bad
    //      r       i       +           T           T           r
    //      r       i       +           F           T           r
    //      r       i       +           F           F           bad
    //
    // The following combinations are prevented from occurring by the UI, as they
    // don''t really make sense:
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           F           i
    //      i       r       +           T           F           bad
    //      r       i       =           T           F           bad
    //      r       i       +           T           F           bad
    //
    prefAllowIntToRealPromotion = "bridgepoint_prefs_allow_int_to_real_promotion";
    prefAllowRealToIntCoercion = "bridgepoint_prefs_allow_real_to_int_coercion";

    if ( dt1_dt.Name == "integer" )
      if ( dt2_dt.Name == "real" )
        if ( param.op == "assign" )
          if ( PREF::getBoolean( name:prefAllowRealToIntCoercion ) == true )
	      	return param.dt1;
          else
        	return GD::NULL_UNIQUE_ID();
          end if;
        elif ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt2;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    elif ( dt1_dt.Name == "real" )
      if ( dt2_dt.Name == "integer" )
        if ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt1;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    else
      return GD::NULL_UNIQUE_ID();
    end if;
  end if;
else
    // If we are not at the domain level, then we need to look for the datatypes
    // in the system-level datatype package(s)
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where (selected.Name == cur_sys_name);

        select any dt1_dt related by sys->G_EIS[R9100]->
                    PE_PE[R9100]->S_DT[R8001] where selected.DT_ID == param.dt1;

    if empty dt1_dt
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
    end if;

    // If we are not at the domain level, then we need to look for the datatypes
    // in the system-level datatype package(s)
    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where (selected.Name == cur_sys_name);
        select any dt2_dt related by sys->G_EIS[R9100]->
                    PE_PE[R9100]->S_DT[R8001] where selected.DT_ID == param.dt2;

    if empty dt2_dt
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <dt2_dt> is empty.",path:"PathNotProvided");
    end if;

  // Set up some flags to be used in the type-equality checks
  foundCDTLHS = false;
  foundCDTRHS = false;
  areCompatible = false;

  // If it''s a UDT, perform compatability tests on the underlying core type
  select one udt1 related by dt1_dt->S_UDT[R17];
  if ( not_empty udt1 )
    foundCDTLHS = true;
    select one dt1_dt related by udt1->S_DT[R18];
  end if;
  select one udt2 related by dt2_dt->S_UDT[R17];
  if ( not_empty udt2 )
    foundCDTRHS = true;
    select one dt2_dt related by udt2->S_DT[R18];
  end if;

  // Check if either is a CDT
  select one cdt1 related by dt1_dt->S_CDT[R17];
  if ( not_empty cdt1 )
    foundCDTLHS = true;
  end if;
  select one cdt2 related by dt2_dt->S_CDT[R17];
  if ( not_empty cdt2 )
    foundCDTRHS = true;
  end if;

  select one irdt1 related by dt1_dt->S_IRDT[R17];

  dt1_is_ir = not_empty irdt1 and not irdt1.isSet;
  dt1_is_irs = not_empty irdt1 and irdt1.isSet;

  select one irdt2 related by dt2_dt->S_IRDT[R17];
  dt2_is_ir = not_empty irdt2 and not irdt2.isSet;
  dt2_is_irs = not_empty irdt2 and irdt2.isSet;

  /**
   *  If both types are not IRDTs then they are incompatible, with
   *  one exception inst_ref<Object>
   */
  if(dt1_is_ir and (not dt2_is_ir and not ::has_substring(p1_base: dt2_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  if(dt1_is_irs and (not dt2_is_irs and not ::has_substring(p1_base: dt2_dt.Name,
                              p2_str: "inst_ref_set<Object>", p3_fromIndex: 0)))
    return GD::NULL_UNIQUE_ID();
  end if;

  /**
   *  Check the opposite, where dt1 is inst_ref<Object> and dt2 is IRDT
   */
  if((not dt1_is_ir and not ::has_substring(p1_base: dt1_dt.Name,
                                  p2_str: "inst_ref<Object>", p3_fromIndex: 0))
                                  and dt2_is_ir)
    return GD::NULL_UNIQUE_ID();                                  
  end if;

  if((not dt1_is_irs and not ::has_substring(p1_base: dt1_dt.Name,
                                p2_str: "inst_ref_set<Object", p3_fromIndex: 0))
                                and dt2_is_irs)
    return GD::NULL_UNIQUE_ID();
  end if;

  if(not dt1_is_ir)
    // check for special case inst_refs
    dt1_is_ir = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0)
                   or ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0);
  end if;

  if(not dt1_is_irs)
    // check for special case inst_ref_sets
    dt1_is_irs = ::has_substring(p1_base: dt1_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0);  
  end if;

  if ( foundCDTLHS and foundCDTRHS )
    if ( dt1_dt.Name == dt2_dt.Name )
      areCompatible = true;
    end if;
  else
    if ( dt1_dt.DT_ID == dt2_dt.DT_ID )
      areCompatible = true;
    end if;
  end if;

  if ( areCompatible )
    // only check for disallowed operations, since they are fewer
    if ( (not dt1_is_ir and not dt1_is_irs and dt1_dt.Name != "boolean") and
        (param.op == "and" or param.op == "or")  )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "boolean" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "string" and
       ( param.op == "-" or param.op == "*" or param.op == "/" or param.op == "%") )
      return GD::NULL_UNIQUE_ID();
    elif ( dt1_dt.Name == "unique_id" and
       ( param.op == "+" or param.op == "-" or param.op == "*" or param.op == "/"  or
         param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "*" or param.op == "/" or param.op == "%"  or
         param.op == ">" or param.op == "<" or param.op == ">=" or param.op == "<=" ) )
      return GD::NULL_UNIQUE_ID();
    elif ( (dt1_is_ir or dt1_is_irs) and
       ( param.op == "and" or param.op == "or" or param.op == "+"  or
         param.op == "-" ) )
      return_type = param.dt1;
      if ( dt1_is_ir )
        // The result of an operation on two inst_ref''s is an inst_ref_set.  So,
        // locate the appropriate inst_ref_set, or error if it doesn''t exist.
        select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
        select any irsdt related by irdt1_obj->S_IRDT[R123] where selected.isSet == true;
        if ( empty irsdt )
          // TODO - it would be nice to report a meaningful parse error here.
          // However, we don''t have a token to pass to the error reporting function.
          // Also, the error reporting function does not return, so not sure how that
          // affects downstream code that uses the return value.
          return_type = GD::NULL_UNIQUE_ID();
        else
          return_type = irsdt.DT_ID;
        end if;
      end if;
      return return_type;
    else
      return param.dt1;
    end if;
  else
    //   The following truth table represents the logic of this inst_ref checking
    //   block.  Any other operations on mixed inst_ref and inst_ref_set are
    //   invalid.  Also, the referenced class must match (i.e. you can''t perform
    //   an operation such as inst_ref<foo> + inst_ref<bar>).
    //
    //      left               right
    //      type           op  type             return
    //      -------------  --  --------------   ------
    //      <inst_ref>      |  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      &  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      +  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref>      -  <inst_ref_set>   <inst_ref_set>
    //      <inst_ref_set>  |  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  &  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  +  <inst_ref>       <inst_ref_set>
    //      <inst_ref_set>  -  <inst_ref>       <inst_ref_set>
    if ( dt1_is_ir or dt1_is_irs )
      if ( param.op != "and" and param.op != "or" and param.op != "+" and
         param.op != "-" )
        return GD::NULL_UNIQUE_ID();
      end if;

      // Now that we''ve established we''re using a valid operator, check that the
      // reference and set are for the same class
      select one irdt1_obj related by dt1_dt->S_IRDT[R17]->O_OBJ[R123];
      select one irdt2_obj related by dt2_dt->S_IRDT[R17]->O_OBJ[R123];

      if empty irdt1_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt1_obj> is empty.",path:"PathNotProvided");
      end if;
      if empty irdt2_obj
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "data_types_compatible().  Variable <irdt2_obj> is empty.",path:"PathNotProvided");
      end if;

      if ( irdt1_obj.Obj_ID != irdt2_obj.Obj_ID )
        return GD::NULL_UNIQUE_ID();
      end if;

      // We''ve passed all the checks, so return the set datatype
      if ( dt1_is_irs )
        return param.dt1;
      else
        return param.dt2;
      end if;
    end if;

    // Disallow boolean operations of non-matching data types
    if ( param.op == "and" or param.op == "or" )
      return GD::NULL_UNIQUE_ID();
    end if;
    //
    // The follow truth table represents the logic this block implements.
    // Operator "=" means assignment, operator "+" means all other operators.
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           T           i
    //      i       r       =           F           T           bad
    //      i       r       =           F           F           bad
    //      i       r       +           T           T           r
    //      i       r       +           F           T           r
    //      i       r       +           F           F           bad
    //      r       i       =           T           T           r
    //      r       i       =           F           T           r
    //      r       i       =           F           F           bad
    //      r       i       +           T           T           r
    //      r       i       +           F           T           r
    //      r       i       +           F           F           bad
    //
    // The following combinations are prevented from occurring by the UI, as they
    // don''t really make sense:
    //
    //      left    right
    //      type    type    operator    coercion    promotion   return
    //      ----    ----    --------    --------    ---------   ------
    //      i       r       =           T           F           i
    //      i       r       +           T           F           bad
    //      r       i       =           T           F           bad
    //      r       i       +           T           F           bad
    //
    prefAllowIntToRealPromotion = "bridgepoint_prefs_allow_int_to_real_promotion";
    prefAllowRealToIntCoercion = "bridgepoint_prefs_allow_real_to_int_coercion";

    if ( dt1_dt.Name == "integer" )
      if ( dt2_dt.Name == "real" )
        if ( param.op == "assign" )
          if ( PREF::getBoolean( name:prefAllowRealToIntCoercion ) == true )
	      	return param.dt1;
          else
        	return GD::NULL_UNIQUE_ID();
          end if;
        elif ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt2;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    elif ( dt1_dt.Name == "real" )
      if ( dt2_dt.Name == "integer" )
        if ( PREF::getBoolean( name:prefAllowIntToRealPromotion ) == true )
      	  return param.dt1;
        else
      	  return GD::NULL_UNIQUE_ID();
        end if;
      else
        return GD::NULL_UNIQUE_ID();
      end if;
    else
      return GD::NULL_UNIQUE_ID();
    end if;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("da006cd5-c8c4-4356-b912-6a3491763316",
	"974587d0-53a6-48b2-92dc-b76283f1a904",
	'dt1',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("bc5018d7-eee2-47b1-9aef-6bea352629c8",
	"974587d0-53a6-48b2-92dc-b76283f1a904",
	'dt2',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"da006cd5-c8c4-4356-b912-6a3491763316",
	'');
INSERT INTO S_SPARM
	VALUES ("9956f10f-480f-4fc0-ae58-cef36504bac3",
	"974587d0-53a6-48b2-92dc-b76283f1a904",
	'op',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bc5018d7-eee2-47b1-9aef-6bea352629c8",
	'');
INSERT INTO PE_PE
	VALUES ("974587d0-53a6-48b2-92dc-b76283f1a904",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bec38bbc-05ab-4b5a-babc-3dae315f20a6",
	"00000000-0000-0000-0000-000000000000",
	'binary_operator_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'create object instance bin of V_BIN;
bin.Operator = param.a1_text;
create object instance val of V_VAL;
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
relate val to blk across R826;
if ( param.a2_dt_name != "" )

    cur_sys_name = ::getSystemName();
    select any sys from instances of S_SYS where selected.Name == cur_sys_name;
    dt_id = GD::NULL_UNIQUE_ID();
    if not_empty sys
      dt_id = sys.getCoreTypeId(name:param.a2_dt_name);
    end if;
    select any pe from instances of PE_PE where selected.Element_ID == dt_id;
    select one dt related by pe->S_DT[R8001];

  if ( not_empty dt )
    relate val to dt across R820;
  else
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
      "binary_operator_create().  Variable <dt> is empty.",path:"PathNotProvided");
  end if;
end if;
relate val to bin across R801;
return val.Value_ID;






































































































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("eb2f0ed8-da68-45d5-ab7a-9e5b5589c847",
	"bec38bbc-05ab-4b5a-babc-3dae315f20a6",
	'a1_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("78a9751a-3939-4ddf-b2d2-245a0eb53046",
	"bec38bbc-05ab-4b5a-babc-3dae315f20a6",
	'a2_dt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"eb2f0ed8-da68-45d5-ab7a-9e5b5589c847",
	'');
INSERT INTO PE_PE
	VALUES ("bec38bbc-05ab-4b5a-babc-3dae315f20a6",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	"00000000-0000-0000-0000-000000000000",
	'unary_operation_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any operand from instances of V_VAL
      where ( selected.Value_ID == param.a5_val_id );
if ( empty operand  )
    ERR::reportParseError( msg: "Operand not found for " + param.a2_op_type,
        token: param.a1_rule_token );
else
    select one op_dt related by operand->S_DT[R820];
    if ( empty op_dt )
      operand.dispose();
      ERR::reportParseError( msg: "Operand for "+param.a2_op_type+"  has unknown data type.",
            token: param.a1_rule_token );
    else
      select one op_udt related by op_dt->S_UDT[R17];
      if ( not_empty op_udt )
        // use the udt''s core data type
        coreId = op_udt.getCoreType();
        select any corePE from instances of PE_PE
                                        where (selected.Element_ID == coreId);
        select one op_dt related by corePE->S_DT[R8001];
      end if;
      if ( op_dt.Name != param.a3_op_dt_name )
        operand.dispose();
        ERR::reportParseError( msg: "Operand for "+param.a2_op_type+" is not of type "
                     +param.a3_op_dt_name,
            token: param.a1_rule_token );
      else
        create object instance u of V_UNY;
        u.Operator = param.a6_text;
        create object instance val of V_VAL;
        current_scope = ::get_current_scope();
        select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
        relate val to blk across R826;
          cur_sys_name = ::getSystemName();
          select any sys from instances of S_SYS where selected.Name == cur_sys_name;
          dt_id = GD::NULL_UNIQUE_ID();
          if not_empty sys
            dt_id = sys.getCoreTypeId(name:param.a4_dt_name);
          end if;
          select any pe from instances of PE_PE where selected.Element_ID == dt_id;
          select one result_dt related by pe->S_DT[R8001]; 
        if ( not_empty result_dt )
          relate val to result_dt across R820;
        else
          USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                 "unary_operation_validate().  Variable <result_dt> is empty.",path:"PathNotProvided");
        end if;
        relate val to u across R801;
        relate u to operand across R804;
        return val.Value_ID;
    end if;
  end if;
end if;
return param.a7_rule_id;
',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bf79b4ab-7e9e-402d-950b-74e4bd86b458",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a1_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f536098e-ff3a-4477-8ebe-7d57e9e47fe0",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a2_op_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bf79b4ab-7e9e-402d-950b-74e4bd86b458",
	'');
INSERT INTO S_SPARM
	VALUES ("6b7ef559-e02f-473f-9a91-443abd1de5b0",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a3_op_dt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f536098e-ff3a-4477-8ebe-7d57e9e47fe0",
	'');
INSERT INTO S_SPARM
	VALUES ("e4980a73-aeb2-4d12-ab3c-ff77ac28873b",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a4_dt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6b7ef559-e02f-473f-9a91-443abd1de5b0",
	'');
INSERT INTO S_SPARM
	VALUES ("18ae072d-f563-4ab5-b6ba-bc3613b77f33",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a5_val_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"e4980a73-aeb2-4d12-ab3c-ff77ac28873b",
	'');
INSERT INTO S_SPARM
	VALUES ("f0e487ca-6f7d-44e3-a71a-c3e0a5c38c86",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a6_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"18ae072d-f563-4ab5-b6ba-bc3613b77f33",
	'');
INSERT INTO S_SPARM
	VALUES ("a7e8265f-d2d4-43b3-97a7-c1bdab3fb4d3",
	"89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	'a7_rule_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"f0e487ca-6f7d-44e3-a71a-c3e0a5c38c86",
	'');
INSERT INTO PE_PE
	VALUES ("89020573-5d3b-429e-9deb-cc0fe28d6c8a",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("10e81b43-c4b7-4f6f-b2f9-0386e3aac42d",
	"00000000-0000-0000-0000-000000000000",
	'get_current_scope',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'act_id = ::get_current_context();
select any act from instances of ACT_ACT where ( selected.Action_ID == act_id );
if ( empty act )
  return GD::NULL_UNIQUE_ID();
else
  select one scope related by act->ACT_BLK[R699];
  if ( empty scope )
    return GD::NULL_UNIQUE_ID();
  else
    return scope.Block_ID;
  end if;
end if;

































































































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("10e81b43-c4b7-4f6f-b2f9-0386e3aac42d",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b7ee7d61-5d4a-4a03-a712-cc04e16b5722",
	"00000000-0000-0000-0000-000000000000",
	'get_enclosing_block',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any blk from instances of ACT_BLK where ( selected.Block_ID == param.block_id );

select one act related by blk->ACT_ACT[R650];
if ( not_empty act )
  // we are the root block
  return GD::NULL_UNIQUE_ID();
else
  select one whl_stmt related by blk->ACT_WHL[R608];
  if ( not_empty whl_stmt )
    select one enclosing_block related by whl_stmt->ACT_SMT[R603]->ACT_BLK[R602];
    return enclosing_block.Block_ID;
  else
    select one if_stmt related by blk->ACT_IF[R607];
    if ( not_empty if_stmt )
      select one enclosing_block related by if_stmt->ACT_SMT[R603]->ACT_BLK[R602];
      return enclosing_block.Block_ID;
    else
      select one elif_stmt related by blk->ACT_EL[R658];
      if ( not_empty elif_stmt )
        select one enclosing_block related by elif_stmt->ACT_SMT[R603]->ACT_BLK[R602];
        return enclosing_block.Block_ID;
      else
        select one else_stmt related by blk->ACT_E[R606];
        if ( not_empty else_stmt )
          select one enclosing_block related by else_stmt->ACT_SMT[R603]->ACT_BLK[R602];
          return enclosing_block.Block_ID;
        else
          select one for_stmt related by blk->ACT_FOR[R605];
          if ( not_empty for_stmt )
            select one enclosing_block related by for_stmt->ACT_SMT[R603]->ACT_BLK[R602];
            return enclosing_block.Block_ID;
          else
            ERR::reportParseError( msg: "Unable to determine enclosing block",
                      token: param.rule_token );
          end if;
        end if;
      end if;
    end if;
  end if;
end if;

return GD::NULL_UNIQUE_ID();





























































































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ec17ca82-1be9-4ff6-ba3b-a8d40c36de74",
	"b7ee7d61-5d4a-4a03-a712-cc04e16b5722",
	'block_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("05f4f1ca-97d0-4bd3-ae7e-49d95c164484",
	"b7ee7d61-5d4a-4a03-a712-cc04e16b5722",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"ec17ca82-1be9-4ff6-ba3b-a8d40c36de74",
	'');
INSERT INTO PE_PE
	VALUES ("b7ee7d61-5d4a-4a03-a712-cc04e16b5722",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a8de1952-03e6-41cc-b4f3-6a462f0f44e6",
	"00000000-0000-0000-0000-000000000000",
	'get_var_in_scope',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK
    where ( selected.Block_ID == current_scope );

select any var_inst related by block->V_VAR[R823]
  where ( selected.Name == param.name );

if ( not_empty var_inst )
  return var_inst.Var_ID;
else
  // search enclosing blocks for variable
  encl_block_id = ::get_enclosing_block( block_id: current_scope, rule_token: param.rule_token );
  while ( encl_block_id != GD::NULL_UNIQUE_ID() and empty var_inst)
    select any enclosing_block from instances of ACT_BLK
        where ( selected.Block_ID == encl_block_id );
    select any var_inst related by enclosing_block->V_VAR[R823] 
         where ( selected.Name == param.name );
    if ( not_empty var_inst )
      return var_inst.Var_ID;
    else
      encl_block_id = ::get_enclosing_block( block_id: encl_block_id, rule_token: param.rule_token );
    end if;
  end while;
end if;

return GD::NULL_UNIQUE_ID();


























































































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("215e1ce7-11c0-4558-b810-2d96167567d8",
	"a8de1952-03e6-41cc-b4f3-6a462f0f44e6",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("07ebecb3-86d0-434f-80b5-e33a6cb6f124",
	"a8de1952-03e6-41cc-b4f3-6a462f0f44e6",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"215e1ce7-11c0-4558-b810-2d96167567d8",
	'');
INSERT INTO PE_PE
	VALUES ("a8de1952-03e6-41cc-b4f3-6a462f0f44e6",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("14d6f097-f771-428d-84da-a8f65192289d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_operator_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any operand from instances of V_VAL
      where ( selected.Value_ID == param.a1_variable_id );
select one op_dt related by operand->S_DT[R820];
if (empty op_dt)
      ERR::reportParseError( msg: "Operand for "+ param.a2_operator_name +" operator"+"  has unknown data type.",
            token: param.a4_rule_token ); 
end if;
select one irdt related by op_dt->S_IRDT[R17];
if ( (::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Timer>", p3_fromIndex: 0) == true ) or
     (::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Mapping>", p3_fromIndex: 0) == true ))
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name + " operator", a3_op_dt_name: "inst_ref<Object>",
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
elif ( ::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref<Object>", p3_fromIndex: 0) or
       ::has_substring(p1_base: op_dt.Name, p2_str: "inst_ref_set<Object>", p3_fromIndex: 0) or
       not_empty irdt )
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name  + " operator", a3_op_dt_name: op_dt.Name,
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
else
  return ::unary_operation_validate( a1_rule_token: param.a4_rule_token,
      a2_op_type: param.a2_operator_name + " operator", a3_op_dt_name: "inst_ref<Object>",
      a4_dt_name: param.a3_op_dt, a5_val_id: param.a1_variable_id,
      a6_text: param.a2_operator_name, a7_rule_id: param.a5_rule_id );
end if;',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("138b5abe-9db5-4f2b-ba9d-6e7dd96f5c51",
	"14d6f097-f771-428d-84da-a8f65192289d",
	'a1_variable_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6317323e-a8fb-4624-bf20-35c92b351ab1",
	"14d6f097-f771-428d-84da-a8f65192289d",
	'a2_operator_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"138b5abe-9db5-4f2b-ba9d-6e7dd96f5c51",
	'');
INSERT INTO S_SPARM
	VALUES ("2fd944ae-635f-4ad3-a004-c416e07e0d30",
	"14d6f097-f771-428d-84da-a8f65192289d",
	'a3_op_dt',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6317323e-a8fb-4624-bf20-35c92b351ab1",
	'');
INSERT INTO S_SPARM
	VALUES ("5b0764e8-1803-4657-a9f2-5dcf30a2530a",
	"14d6f097-f771-428d-84da-a8f65192289d",
	'a4_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"2fd944ae-635f-4ad3-a004-c416e07e0d30",
	'');
INSERT INTO S_SPARM
	VALUES ("4a97b837-fd59-431f-b12d-436890eca473",
	"14d6f097-f771-428d-84da-a8f65192289d",
	'a5_rule_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"5b0764e8-1803-4657-a9f2-5dcf30a2530a",
	'');
INSERT INTO PE_PE
	VALUES ("14d6f097-f771-428d-84da-a8f65192289d",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("88800271-4ef6-41e6-a9f7-26827bc8c44b",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_relationship',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a3_rel == GD::NULL_UNIQUE_ID() )
  ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "Invalid association specification",
      token: param.a5_rule_token );
end if;

select any left_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a1_left );
select any right_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a2_right );
select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a3_rel );
select one r_assoc related by r_rel->R_ASSOC[R206];
select one rel_assr related by r_assoc->R_ASSR[R211];
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
rel_is_reflexive = r_rel.is_reflexive();

select many oir_set related by r_rel->R_OIR[R201];
left_object_found = false;
right_object_found = false;
select any left_oir from instances of R_OIR;
select any right_oir from instances of R_OIR;
for each oir in oir_set
  if ( left_object_found and right_object_found )
    break;
  end if;
      // We must get two distinct class-in-associations if we have a
      // reflexive association.
  if ( oir.Obj_ID == left_obj.Obj_ID )
    if ( not left_object_found )
      if ( empty r_assoc )
        left_object_found = true;
        left_oir = oir;
      else
        if ( not rel_is_reflexive )
          left_object_found = true;
          left_oir = oir;
        else
          // reflexive link association
          select one rel_assr related by r_assoc->R_ASSR[R211];
          if ( left_obj.Obj_ID == rel_assr.Obj_ID )
            // navigating from assr back to aone/aoth
            left_object_found = true;
            left_oir = oir;
          elif ( right_obj.Obj_ID == rel_assr.Obj_ID )
            // navigating from aone/aoth to assr for reflexive link association
            // check for the correct phrase
            if ( blk.TempBuffer != "" )
              dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
              if ( oir.get_text_phrase() == dest_rel_phrase )
                left_object_found = true;
                left_oir = oir;
              else
                select one aone related by r_assoc->R_AONE[R209];
                select one aoth related by r_assoc->R_AOTH[R210];
                if ( aone.Txt_Phrs != dest_rel_phrase and 
                     aoth.Txt_Phrs != dest_rel_phrase )
                  // invalid phrase, use this oir for later code to throw error for bad phrase
                  left_object_found = true;
                  left_oir = oir;
                end if;
              end if;  // oir.get_text_phrase() == dest_rel_phrase
            else
              // use this oir for later code to detect empty phrase
              left_object_found = true;
              left_oir = oir;
            end if;  // blk.TempBuffer != "" 
          else
            // navigating directly without using assr
            left_object_found = true;
            left_oir = oir;
          end if;  // left_obj is assr
        end if; // not rel_is_reflexive
      end if;  // empty r_assoc
    end if;  // not left_object_found
  end if;  // oir.Obj_ID == left_obj.Obj_ID
  if ( oir.Obj_ID == right_obj.Obj_ID )
    if ( not left_object_found or oir.OIR_ID != left_oir.OIR_ID )
      right_object_found = true;
      right_oir = oir;
    end if;
  end if;
end for;
if ( not left_object_found or not right_object_found )
  ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "The specified association ->R"+
          GD::int_to_string(value: r_rel.Numb) + "<- does not exist between classes ->"+
          left_obj.Name+"<- and ->"+right_obj.Name+"<-",
      token: param.a5_rule_token );
else
  // make sure that the right_oir is the one with the specified phrase for reflexive rels
  if ( rel_is_reflexive )
    if ( blk.TempBuffer != "" )
      swap_oirs = false;
      // empty phrases for reflexive associations are handled elsewhere
      dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
      if ( empty r_assoc )
        if ( right_oir.get_text_phrase() != dest_rel_phrase )
          swap_oirs = true;
        end if;
      else
        // figure out if the link class in in the link
        if ( left_oir.OIR_ID != rel_assr.OIR_ID and right_oir.OIR_ID != rel_assr.OIR_ID )
          // link class is not part of the link
          if ( right_oir.get_text_phrase() != dest_rel_phrase )
            swap_oirs = true;
          end if;
        end if;
      end if;    // empty r_assoc
      if ( swap_oirs )
        temp_oir = left_oir;
        left_oir = right_oir;
        right_oir = temp_oir;
      end if;  // swap_oirs
    end if;  // blk.TempBuffer != ""
  end if;  // is_reflexive
  select one left_oasub related by left_oir->R_RGO[R203]->R_SUB[R205];
  select one right_oasub related by right_oir->R_RGO[R203]->R_SUB[R205];
  if ( not_empty left_oasub and not_empty right_oasub )
    ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "The classes ->" + left_obj.Name+"<- and ->"+right_obj.Name+"<- " +
           "are subtype classes in the association ->R" +
           GD::int_to_string(value: r_rel.Numb) + "<-", 
      token: param.a5_rule_token );
  else
    select one subsup related by r_rel->R_SUBSUP[R206];
    if ( not_empty subsup and param.a4_phrase != GD::NULL_UNIQUE_ID() )
      ::clear_rel_data( a1_chain_start_val: param.a6_chain_start_val, a2_chain_id: param.a7_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
          "A destination association phrase is not allowed for a supertype/subtype association",
          token: param.a5_rule_token );
    else
      if ( ::has_valid_phrase(a1_rel: param.a3_rel, a2_phrase: param.a4_phrase,
         a3_right_oir_id: right_oir.OIR_ID, a4_right_obj_name: right_obj.Name, a5_right_obj_id: right_obj.Obj_ID,
         a6_left_oir_id: left_oir.OIR_ID, a7_left_obj_name: left_obj.Name, a8_left_obj_id: left_obj.Obj_ID,
         a9_rule_token: param.a5_rule_token, b1_chain_start_val: param.a6_chain_start_val,
        b2_chain_id: param.a7_chain_id  ) )
        return ::get_right_object_multiplicity(a1_left: left_oir.OIR_ID, a2_rel: r_rel.Rel_ID, a3_right: right_oir.OIR_ID);
      end if;
    end if;
  end if;
end if;
return Multiplicity::Unknown;



















































































',
	"52bea3da-25a3-4237-8932-36aba01a786f",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c2edda39-f7d2-4984-b85c-79bbd9db1509",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a1_left',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("1937661a-4e81-4723-a81c-7b26588e262b",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a2_right',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"c2edda39-f7d2-4984-b85c-79bbd9db1509",
	'');
INSERT INTO S_SPARM
	VALUES ("bb0274a0-d497-4e58-9b67-15aad745ba81",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a3_rel',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"1937661a-4e81-4723-a81c-7b26588e262b",
	'');
INSERT INTO S_SPARM
	VALUES ("688b8f10-8cb7-44f1-a70c-cb97b589e381",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a4_phrase',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"bb0274a0-d497-4e58-9b67-15aad745ba81",
	'');
INSERT INTO S_SPARM
	VALUES ("9594d36c-59d0-4821-b013-a4a533c2143b",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a5_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"688b8f10-8cb7-44f1-a70c-cb97b589e381",
	'');
INSERT INTO S_SPARM
	VALUES ("aa248f46-2594-4763-8408-3689eae85e4b",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a6_chain_start_val',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"9594d36c-59d0-4821-b013-a4a533c2143b",
	'');
INSERT INTO S_SPARM
	VALUES ("b4a7629b-7f10-4a0c-98f8-8816d956eef2",
	"88800271-4ef6-41e6-a9f7-26827bc8c44b",
	'a7_chain_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"aa248f46-2594-4763-8408-3689eae85e4b",
	'');
INSERT INTO PE_PE
	VALUES ("88800271-4ef6-41e6-a9f7-26827bc8c44b",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("52bea3da-25a3-4237-8932-36aba01a786f",
	"00000000-0000-0000-0000-000000000000",
	'Multiplicity',
	'The Multiplicity data type allows specification of the range of allowable cardinality values.
--------------------------------------------------------------
Bridge:GD, ALS',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO S_SYNC
	VALUES ("9a5948d4-ec6e-450b-8838-22a45d459fa0",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_assoc_relationship',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a4_rel == GD::NULL_UNIQUE_ID() )
  ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
      "Invalid association specification",
      token: param.a6_rule_token );
end if;

select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a4_rel );

select one r_assoc related by r_rel->R_ASSOC[R206];
if ( empty r_assoc )
  ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
  ERR::reportParseError( msg: 
       "Association ->R" +
          GD::int_to_string(value: r_rel.Numb) + "<- is not linked",
          token: param.a6_rule_token );
else
  select any left_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a1_left );
  select any right_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a2_right );
  select any assoc_obj  from instances of O_OBJ where ( selected.Obj_ID == param.a3_assoc );

  left_object_found = false;
  right_object_found = false;
  assoc_obj_found = false;
  select any left_oir from instances of R_OIR;
  select any right_oir from instances of R_OIR;
  select any assoc_oir from instances of R_OIR;

  select many oir_set related by r_rel->R_OIR[R201];
  for each oir in oir_set
    if ( left_object_found and right_object_found and assoc_obj_found )
      break;
    end if;
    if ( oir.Obj_ID == left_obj.Obj_ID )
      if ( not left_object_found )
        left_object_found = true;
        left_oir = oir;
        // we need to get back to the top of this loop 
        // to prevent right_oir being set for reflexive associations
        continue;
      end if;
    end if;
    if ( oir.Obj_ID == right_obj.Obj_ID )
      right_object_found = true;
      right_oir = oir;
    end if;
    if ( oir.Obj_ID == assoc_obj.Obj_ID )
      assoc_obj_found = true;
      assoc_oir = oir;
    end if;
  end for;
  if ( not assoc_obj_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+assoc_obj.Name+"<- is not the link class between " +
           "classes ->"+left_obj.Name+"<- and ->"+right_obj.Name+
            "<- in link association ->R"+GD::int_to_string(value: r_rel.Numb)+"<-",
          token: param.a6_rule_token );
  elif ( not left_object_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+left_obj.Name+"<- does not participate in the link association ->R"+
           GD::int_to_string(value: r_rel.Numb) +"<-",
          token: param.a6_rule_token );
  elif ( not right_object_found )
    ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
           "Class ->"+right_obj.Name+"<- does not participate in the link association ->R"+
           GD::int_to_string(value: r_rel.Numb) +"<-",
          token: param.a6_rule_token );
  else
    // Make sure each class is at its correct position in association. First check
    // link class, then associated classes.
    select one rel_assr related by r_assoc->R_ASSR[R211];
    select one oir_assr related by assoc_oir->R_RGO[R203]->R_ASSR[R205];
    if ( rel_assr != oir_assr )
      ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
           "Class ->"+assoc_obj.Name+"<- is incorrectly specified in link association ->R" +
            GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
    else
      select one rel_aone related by r_assoc->R_AONE[R209];
      select one rel_aoth related by r_assoc->R_AOTH[R210];
      select one l_aone related by left_oir->R_RTO[R203]->R_AONE[R204];
      select one l_aoth related by left_oir->R_RTO[R203]->R_AOTH[R204];
      select one r_aone related by right_oir->R_RTO[R203]->R_AONE[R204];
      select one r_aoth related by right_oir->R_RTO[R203]->R_AOTH[R204];
      if ( (empty l_aone and empty l_aoth) or
           (not_empty l_aone and l_aone != rel_aone) or
           (not_empty l_aoth and l_aoth != rel_aoth) )
        ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
           "Class ->"+left_obj.Name+"<- is incorrectly specified in link association ->R"+
           GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
      elif ( (empty r_aone and empty r_aoth) or
           (not_empty r_aone and r_aone != rel_aone) or
           (not_empty r_aoth and r_aoth != rel_aoth) )
        ::clear_rel_data( a1_chain_start_val: param.a7_chain_start_val, a2_chain_id: param.a8_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
           "Class ->"+right_obj.Name+"<- is incorrectly specified in link association ->R"+
           GD::int_to_string(value: r_rel.Numb)+"<-",
            token: param.a6_rule_token );
       else
         return ::has_valid_phrase(a1_rel: param.a4_rel, a2_phrase: param.a5_phrase,
            a3_right_oir_id: right_oir.OIR_ID, a4_right_obj_name: right_obj.Name, a5_right_obj_id: right_obj.Obj_ID,
            a6_left_oir_id: left_oir.OIR_ID, a7_left_obj_name: left_obj.Name, a8_left_obj_id: left_obj.Obj_ID,
            a9_rule_token: param.a6_rule_token, b1_chain_start_val: param.a7_chain_start_val, b2_chain_id: param.a8_chain_id);
       end if;
    end if;
  end if;
end if;

return true;




















































































',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b83a8bae-49e4-47fb-8497-0f57ce65b044",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a1_left',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("64350d23-ad40-4bff-b0fd-51fb91c4875a",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a2_right',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"b83a8bae-49e4-47fb-8497-0f57ce65b044",
	'');
INSERT INTO S_SPARM
	VALUES ("0f27b421-cb4c-4f79-95bb-a73c97d83447",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a3_assoc',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"64350d23-ad40-4bff-b0fd-51fb91c4875a",
	'');
INSERT INTO S_SPARM
	VALUES ("2467488a-2fc3-4c92-a749-f522390bd02c",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a4_rel',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"0f27b421-cb4c-4f79-95bb-a73c97d83447",
	'');
INSERT INTO S_SPARM
	VALUES ("69501400-d662-48a8-9ccc-d930571979ed",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a5_phrase',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"2467488a-2fc3-4c92-a749-f522390bd02c",
	'');
INSERT INTO S_SPARM
	VALUES ("77a3bc0e-4f62-44fe-acc6-9c0217ed80ec",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a6_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"69501400-d662-48a8-9ccc-d930571979ed",
	'');
INSERT INTO S_SPARM
	VALUES ("b71baef1-bb40-4729-bba9-13c547e08c11",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a7_chain_start_val',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"77a3bc0e-4f62-44fe-acc6-9c0217ed80ec",
	'');
INSERT INTO S_SPARM
	VALUES ("d1019739-a16e-4f07-bad2-4bfa5a364d24",
	"9a5948d4-ec6e-450b-8838-22a45d459fa0",
	'a8_chain_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"b71baef1-bb40-4729-bba9-13c547e08c11",
	'');
INSERT INTO PE_PE
	VALUES ("9a5948d4-ec6e-450b-8838-22a45d459fa0",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a870117e-ae49-49b4-9e36-3e9d2aed3230",
	"00000000-0000-0000-0000-000000000000",
	'has_valid_phrase',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a1_rel );
if ( r_rel.is_reflexive() )
  if ( param.a2_phrase != GD::NULL_UNIQUE_ID() )
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
    dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
    dest_rel_oir_id = param.a3_right_oir_id;
    left_oir_id = param.a6_left_oir_id;
    right_oir_id = param.a3_right_oir_id;
    if ( param.a8_left_obj_id == param.a5_right_obj_id )
      select any right_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
      select any left_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
      select many cias related by r_rel->R_OIR[R201];
      for each cia in cias
	    if (cia.OIR_ID == param.a3_right_oir_id)
		  right_oir = cia;
	    elif (cia.OIR_ID == param.a6_left_oir_id)
		  left_oir = cia;	
	    end if;
      end for;
      if ( left_oir.get_text_phrase() == dest_rel_phrase )
        dest_rel_oir_id = left_oir.OIR_ID;
      elif ( right_oir.get_text_phrase() != dest_rel_phrase )
        ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
        ERR::reportParseError( msg: 
                 "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
              GD::int_to_string(value: r_rel.Numb) + 
               "<- does not contain destination association phrase ->"+
                 dest_rel_phrase  +"<-",
                 token: param.a9_rule_token );
      end if;
    else
              // We are navigating via the link class, which means we are
              // either at the associated class and going thru the link
              // class or we are at the link class going thru the
              // associated class. In either case, simply make sure the
              // association phrase match either one of the associated classes.
              // Remember we must save the oir affiliated with the phrase;
              // additionally we need to save the left and right oirs so the
              // multiplicity can be determined later.
             
              select one assoc_rel related by r_rel->R_ASSOC[R206]; 
              if ( empty assoc_rel )
                ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                ERR::reportParseError( msg: 
                   "Reflexive association ->R" +
                      GD::int_to_string(value: r_rel.Numb) + 
                      "<- is not linked, and should be",
                   token: param.a9_rule_token );
                  return false;
              end if;
              
              select one rel_associator related by assoc_rel->R_ASSR[R211];
              select one rel_aone related by assoc_rel->R_AONE[R209];
              select one rel_aoth related by assoc_rel->R_AOTH[R210];
              
              select any left_oir from instances of R_OIR where ( selected.OIR_ID == param.a6_left_oir_id );
              select one left_oir_assr related by left_oir->R_RGO[R203]->R_ASSR[R205];
              if ( not_empty rel_associator and not_empty left_oir_assr
                  and rel_associator.OIR_ID == left_oir_assr.OIR_ID )

                  // The left class is the link class and the right is
                  // one of the associators. The destination phrase should match
                  // one of the associators.
                  
                  if ( rel_aone.Txt_Phrs == dest_rel_phrase )
                      right_oir_id = rel_aone.OIR_ID;
                  elif ( rel_aoth.Txt_Phrs == dest_rel_phrase )
                      right_oir_id = rel_aoth.OIR_ID;
                  else
                    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                     ERR::reportParseError( msg: 
                           "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
                           GD::int_to_string(value: r_rel.Numb) + 
                           "<- does not contain destination association phrase ->"+
                           dest_rel_phrase  +"<-",
                         token: param.a9_rule_token );
                      return false;
                   end if;
              else
                  // The left class is one of the associators and the right
                  // class is the link class. Even though the right
                  // class is the link class, the destination phrase
                  // must match with one of the associators, and we must
                  // store the destination phrase of the matching associator.
                  // However, the left_oinir_ptr should be OPPOSITE the phrase.
                  
                  if ( rel_aone.Txt_Phrs == dest_rel_phrase )
                      left_oir_id = rel_aoth.OIR_ID;
                  elif ( rel_aoth.Txt_Phrs == dest_rel_phrase )
                      left_oir_id = rel_aone.OIR_ID;
                  else
                    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
                     ERR::reportParseError( msg: 
                           "Class ->"+ param.a4_right_obj_name+"<- in reflexive association ->R" +
                           GD::int_to_string(value: r_rel.Numb) + 
                           "<- does not contain destination association phrase ->"+
                           dest_rel_phrase  +"<-",
                         token: param.a9_rule_token );
                      return false;
                  end if;
              end if;
    end if;
  else
    ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
    ERR::reportParseError( msg: 
         "The destination association phrase must be specified for reflexive association ->R"+
          GD::int_to_string(value: r_rel.Numb) + "<- between classes ->" + 
             param.a7_left_obj_name+"<- and ->"+param.a4_right_obj_name+"<-",
          token: param.a9_rule_token );
  end if;
else
  // not reflexive
  if ( param.a2_phrase != GD::NULL_UNIQUE_ID() )
    current_scope = ::get_current_scope();
    select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
    dest_rel_phrase = OS::remove_ticks( ticked_string: blk.TempBuffer );
    select any right_oir from instances of R_OIR where ( selected.OIR_ID == param.a3_right_oir_id );
    if ( right_oir.get_text_phrase() != dest_rel_phrase )
      ::clear_rel_data( a1_chain_start_val: param.b1_chain_start_val, a2_chain_id: param.b2_chain_id, a3_where_val: GD::NULL_UNIQUE_ID() );
      ERR::reportParseError( msg: 
              "Class ->"+param.a4_right_obj_name+"<- in association ->R" +
              GD::int_to_string(value: r_rel.Numb) + 
              "<- does not contain destination association phrase ->"+ dest_rel_phrase +"<-",
              token: param.a9_rule_token );
    end if;
  end if;
end if;
return true;















































































',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6eea66f1-bab0-4211-9a1c-e018f51028b1",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a1_rel',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("b2652994-c6d7-424a-99a3-722a16c336b8",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a2_phrase',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"6eea66f1-bab0-4211-9a1c-e018f51028b1",
	'');
INSERT INTO S_SPARM
	VALUES ("9949fccf-5214-4a81-a2a0-7bff47fdc6d4",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a3_right_oir_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"b2652994-c6d7-424a-99a3-722a16c336b8",
	'');
INSERT INTO S_SPARM
	VALUES ("766d0c12-15f8-4b92-be45-1e516317a384",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a4_right_obj_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9949fccf-5214-4a81-a2a0-7bff47fdc6d4",
	'');
INSERT INTO S_SPARM
	VALUES ("c6c76320-a7ea-4567-a52c-acecd3610430",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a5_right_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"766d0c12-15f8-4b92-be45-1e516317a384",
	'');
INSERT INTO S_SPARM
	VALUES ("773890f4-ce56-40ab-9d58-685ccef9e149",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a6_left_oir_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"c6c76320-a7ea-4567-a52c-acecd3610430",
	'');
INSERT INTO S_SPARM
	VALUES ("68b532e2-8dc6-47fc-81e0-7dc20fe9ffb1",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a7_left_obj_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"773890f4-ce56-40ab-9d58-685ccef9e149",
	'');
INSERT INTO S_SPARM
	VALUES ("e80840de-9605-46a7-82ee-ee21c3451ef6",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a8_left_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"68b532e2-8dc6-47fc-81e0-7dc20fe9ffb1",
	'');
INSERT INTO S_SPARM
	VALUES ("c278461f-7098-4bdf-a228-44ecec3be808",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'a9_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"e80840de-9605-46a7-82ee-ee21c3451ef6",
	'');
INSERT INTO S_SPARM
	VALUES ("c9a3c457-a712-4e0f-a859-7eb8425885b0",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'b1_chain_start_val',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"c278461f-7098-4bdf-a228-44ecec3be808",
	'');
INSERT INTO S_SPARM
	VALUES ("6aa060be-8ade-4980-92d2-bec2f4a8300a",
	"a870117e-ae49-49b4-9e36-3e9d2aed3230",
	'b2_chain_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"c9a3c457-a712-4e0f-a859-7eb8425885b0",
	'');
INSERT INTO PE_PE
	VALUES ("a870117e-ae49-49b4-9e36-3e9d2aed3230",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	"00000000-0000-0000-0000-000000000000",
	'process_from_instances',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any var from instances of V_VAR
          where (selected.Var_ID == param.a1_local_var );
  select any stmt from instances of ACT_SMT
          where (selected.Statement_ID ==   param.a2_stmt_id );
  select one irv related by var->V_INT[R814];
  select one irsv related by var->V_INS[R814];
  select one obj related by stmt->ACT_FIO[R603]->O_OBJ[R677];
  if ( param.a5_has_where )
    select one obj related by stmt->ACT_FIW[R603]->O_OBJ[R676];
  end if;
  if ( var.Declared and param.a3_mult == "any" and empty irv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance variable",
        token: param.a4_rule_token );
  elif ( var.Declared and param.a3_mult != "any" and empty irsv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance set variable",
        token: param.a4_rule_token );
  else
    is_implicit = false;
    stmt_ok = false;
    if ( var.Declared )
      if ( param.a3_mult != "any" )
        select one irsv_obj related by irsv->O_OBJ[R819];
        if ( irsv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          is_implicit = false;
          stmt_ok = true;
        end if;
      elif ( param.a3_mult == "any" )
        select one irv_obj related by irv->O_OBJ[R818];
        if ( irv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          is_implicit = false;
          stmt_ok = true;
        end if;
      end if;
    else
      stmt_ok = true;
      is_implicit = true;
      if ( param.a3_mult == "any" )
        var.migrate_to_int();
        select one inst_ref related by var->V_INT[R814];
        relate inst_ref to obj across R818;
        ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      else
        var.migrate_to_ins();
        select one inst_ref_set related by var->V_INS[R814];
        relate inst_ref_set to obj across R819;
        ::connect_inst_ref_var_to_datatype(p1_is_set:true, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      end if;
      var.Declared = true;
    end if;
    if ( stmt_ok )
      if ( param.a5_has_where )
        select one fiw related by stmt->ACT_FIW[R603];
        fiw.cardinality = param.a3_mult;
        fiw.is_implicit = is_implicit;
        relate fiw to var across R665;
      else
        select one fio related by stmt->ACT_FIO[R603];
        fio.cardinality = param.a3_mult;
        fio.is_implicit = is_implicit;
        relate fio to var across R639;
      end if;
    end if;
  end if;
  return stmt.Statement_ID;











































































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3868df78-6ea4-4e18-a3ec-d1f21c18c1eb",
	"3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	'a1_local_var',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f8c9ef02-7154-4a6b-af84-b1159b9af62f",
	"3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	'a2_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"3868df78-6ea4-4e18-a3ec-d1f21c18c1eb",
	'');
INSERT INTO S_SPARM
	VALUES ("f6216eb1-f05c-4769-a056-e240e36a0cd0",
	"3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	'a3_mult',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f8c9ef02-7154-4a6b-af84-b1159b9af62f",
	'');
INSERT INTO S_SPARM
	VALUES ("8bd7aff4-5b32-45f3-aa89-bda687767be3",
	"3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	'a4_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"f6216eb1-f05c-4769-a056-e240e36a0cd0",
	'');
INSERT INTO S_SPARM
	VALUES ("69f56658-f535-4b28-bbf8-9b1f257a4b37",
	"3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	'a5_has_where',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"8bd7aff4-5b32-45f3-aa89-bda687767be3",
	'');
INSERT INTO PE_PE
	VALUES ("3fb5c4b4-f3ce-4854-98de-9315d27a30f8",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9e5957ba-3b78-4742-a22a-d716c5d715da",
	"00000000-0000-0000-0000-000000000000",
	'selected_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.name == "Selected" or param.name == "selected" or param.name == "SELECTED" )
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
  if ( not blk.InWhereSpec )
    ERR::reportParseError( msg: "Keyword ->Selected<- cannot be used outside a where expression",
          token: param.rule_token );
    ::clear_value_data();
  end if;
  return true;
else
  return false;
end if;







































































',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("90cd4e38-1c8a-4245-b432-2775c04061c7",
	"9e5957ba-3b78-4742-a22a-d716c5d715da",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("80f6c6ae-baee-47fd-a4fd-009e743b60e3",
	"9e5957ba-3b78-4742-a22a-d716c5d715da",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"90cd4e38-1c8a-4245-b432-2775c04061c7",
	'');
INSERT INTO PE_PE
	VALUES ("9e5957ba-3b78-4742-a22a-d716c5d715da",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f6607a8d-262e-4e4b-b394-edc9305a1c29",
	"00000000-0000-0000-0000-000000000000",
	'process_related_by',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  select any var from instances of V_VAR
          where (selected.Var_ID == param.a1_local_var );
  select any stmt from instances of ACT_SMT
          where (selected.Statement_ID == param.a2_stmt_id );
  select one sel related by stmt->ACT_SEL[R603];
  select one irv related by var->V_INT[R814];
  select one irsv related by var->V_INS[R814];
  select one link related by sel->ACT_LNK[R637];
  last_link = link;
  mult = "one";
  if ( not_empty irsv )
    mult = "many";
  end if;
  while ( not_empty link )
    last_link = link;
    if ( link.Mult == Multiplicity::Many )
      mult = "many";
    end if;
    select one link related by last_link->ACT_LNK[R604.''precedes''];
  end while;

  if ( param.a3_mult == "one" and mult == "many" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "At least one association has a right class with multiplicity of many.  With SELECT ONE, all right classes must have multiplicity of one",
        token: param.a4_rule_token );
  elif ( param.a3_mult == "any" and mult == "one" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "No right class has multiplicity of many. With SELECT ANY, at least one class must have multiplicity of many",
        token: param.a4_rule_token );
  elif ( param.a3_mult == "many" and mult == "one" )
    if ( not var.Declared )
      var.dispose();
    end if;
    stmt.dispose();
    ERR::reportParseError( msg: "No right class has multiplicity of many. With SELECT MANY, at least one class must have multiplicity of many",
        token: param.a4_rule_token );
  end if;

  select one obj related by last_link->O_OBJ[R678];
  if ( var.Declared and
        (param.a3_mult == "any" or param.a3_mult == "one") and empty irv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance variable",
        token: param.a4_rule_token );
  elif ( var.Declared and param.a3_mult == "many" and empty irsv )
    stmt.dispose();
    ERR::reportParseError( msg: "Variable ->"+var.Name+"<- does not exist in scope as an object instance set variable",
        token: param.a4_rule_token );
  else
    stmt_ok = false;
    if ( var.Declared )
      if ( param.a3_mult == "many" )
        select one irsv_obj related by irsv->O_OBJ[R819];
        if ( irsv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          sel.is_implicit = false;
          stmt_ok = true;
        end if;
      else
        select one irv_obj related by irv->O_OBJ[R818];
        if ( irv_obj.Obj_ID != obj.Obj_ID )
          stmt.dispose();
          ERR::reportParseError( msg: "Variable ->"+var.Name+"<- already exists as a different type",
            token: param.a4_rule_token );
        else
          sel.is_implicit = false;
          stmt_ok = true;
        end if;
      end if;
    else
      stmt_ok = true;
      sel.is_implicit = true;
      if ( param.a3_mult != "many" )
        var.migrate_to_int();
        select one inst_ref related by var->V_INT[R814];
        relate inst_ref to obj across R818;
        ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      else
        var.migrate_to_ins();
        select one inst_ref_set related by var->V_INS[R814];
        relate inst_ref_set to obj across R819;
        ::connect_inst_ref_var_to_datatype(p1_is_set:true, p2_var_id:var.Var_ID, p3_obj_id:obj.Obj_ID);
      end if;
      var.Declared = true;
    end if;
    if ( stmt_ok )
      sel.cardinality = param.a3_mult;
      relate sel to var across R638;
    end if;
  end if;
  return stmt.Statement_ID;

',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e8f2d7b9-8d38-409d-ab42-8af84ee58570",
	"f6607a8d-262e-4e4b-b394-edc9305a1c29",
	'a1_local_var',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("26348fa2-6e4f-46a9-9389-1e6cfb2418fd",
	"f6607a8d-262e-4e4b-b394-edc9305a1c29",
	'a2_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"e8f2d7b9-8d38-409d-ab42-8af84ee58570",
	'');
INSERT INTO S_SPARM
	VALUES ("4092c2cd-ba86-49d8-a8fb-538796340f1a",
	"f6607a8d-262e-4e4b-b394-edc9305a1c29",
	'a3_mult',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"26348fa2-6e4f-46a9-9389-1e6cfb2418fd",
	'');
INSERT INTO S_SPARM
	VALUES ("314c88e2-3163-4807-ac7b-6051d6c7a83d",
	"f6607a8d-262e-4e4b-b394-edc9305a1c29",
	'a4_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"4092c2cd-ba86-49d8-a8fb-538796340f1a",
	'');
INSERT INTO PE_PE
	VALUES ("f6607a8d-262e-4e4b-b394-edc9305a1c29",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("49e18ad7-880a-4408-ae96-5847f0d7c717",
	"00000000-0000-0000-0000-000000000000",
	'get_right_object_multiplicity',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'result_mult = Multiplicity::Unknown;
  
// We also have to get the multiplicity of the right
// class so that the cardinality of the association chain can be determined
// to make sure matches the SELECT ONE/ANY/MANY.
select any r_rel from instances of R_REL where ( selected.Rel_ID == param.a2_rel );
select any right_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
select any left_oir from instances of R_OIR where (selected.OIR_ID == GD::NULL_UNIQUE_ID()); 
select many cias related by r_rel->R_OIR[R201];
for each cia in cias
	if (cia.OIR_ID == param.a3_right)
		right_oir = cia;
	elif (cia.OIR_ID == param.a1_left)
		left_oir = cia;	
	end if;
end for;
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  result_mult = right_oir.get_multiplicity();
else  // empty simp
  select one inh related by r_rel->R_SUBSUP[R206];
  if (not_empty inh )
    result_mult = Multiplicity::One;
  else // empty inh
    select one comp related by r_rel->R_COMP[R206];
    if ( not_empty comp )
      result_mult = right_oir.get_multiplicity();
    else // empty comp
      select one assoc related by r_rel->R_ASSOC[R206];
      if ( not_empty assoc )
        select one assr related by left_oir->R_RGO[R203]->R_ASSR[R205];
        if ( not_empty assr )
          // Real simply, if the left class is the link class,
          // then we should ALWAYS use ONE multiplicity because we can
          // only navigate to ONE and only ONE of the associators.
          
          result_mult = Multiplicity::One;
        else 
          select one aone related by left_oir->R_RTO[R203]->R_AONE[R204];
          if (not_empty aone )
            select one aoth related by right_oir->R_RTO[R203]->R_AOTH[R204];
            if ( not_empty aoth )
              result_mult = right_oir.get_multiplicity();
            else 
              select one assr related by right_oir->R_RGO[R203]->R_ASSR[R205];
              if ( not_empty assr )
                select one assoc_aoth related by assoc->R_AOTH[R210];
                if ( assr.Mult == 0 )
                   if ( r_rel.is_reflexive() )
                    // the roles are not reversed for link reflexive associations
                    if ( aone.Mult == 0 )  // 0 == ONE
                      result_mult = Multiplicity::One;
                    else
                      result_mult = Multiplicity::Many;
                    end if;
                   else
                     if ( assoc_aoth.Mult == 0 )  // 0 == ONE
                       result_mult =Multiplicity::One;
                     else
                        result_mult = Multiplicity::Many;
                     end if;
                  end if;  // is_reflexive
                else
                  result_mult = Multiplicity::Many;
                end if;
              else  // empty assr
                result_mult = Multiplicity::One;
              end if;  // not_empty assr
            end if;  // not_empty aoth
          else 
            select one aoth related by left_oir->R_RTO[R203]->R_AOTH[R204];
            if ( not_empty aoth )
              select one aone related by right_oir->R_RTO[R203]->R_AONE[R204];
              if ( not_empty aone )
                result_mult = right_oir.get_multiplicity();
              else 
                select one assr related by right_oir->R_RGO[R203]->R_ASSR[R205];
                if ( not_empty assr )
                  select one assoc_aone related by assoc->R_AONE[R209];
                  if ( assr.Mult == 0)
                     if ( r_rel.is_reflexive() )
                      // the roles are not reversed for link reflexive associations
                      if ( aoth.Mult == 0 )  // 0 == ONE
                        result_mult = Multiplicity::One;
                      else
                        result_mult = Multiplicity::Many;
                      end if;
                     else
                      if ( assoc_aone.Mult == 0 )  // 0 == ONE
                        result_mult = Multiplicity::One;
                      else
                        result_mult = Multiplicity::Many;
                      end if;
                     end if;
                  else
                    result_mult = Multiplicity::Many;
                  end if;
                else
                  result_mult =Multiplicity::One;
                end if;
              end if;  // not_empty aone
            else  // empty aoth
              result_mult = Multiplicity::One;
            end if;  // not_empty aoth
          end if;  // not_empty aone
        end if;  // not_empty assr
      else  // empty assoc
        result_mult =Multiplicity::One;
      end if;  // not_empty assoc
    end if;  // not_empty comp
  end if;  // not_empty inh
end if;  // not_empty simp


return  result_mult ;



































































',
	"52bea3da-25a3-4237-8932-36aba01a786f",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("57bfdbad-878c-4c7e-9a1c-63f88133a320",
	"49e18ad7-880a-4408-ae96-5847f0d7c717",
	'a1_left',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f79c5c1d-cef3-4508-a2f4-0746f3bb4ac3",
	"49e18ad7-880a-4408-ae96-5847f0d7c717",
	'a2_rel',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"57bfdbad-878c-4c7e-9a1c-63f88133a320",
	'');
INSERT INTO S_SPARM
	VALUES ("5ce4e313-e689-4c25-b168-febca7abbd34",
	"49e18ad7-880a-4408-ae96-5847f0d7c717",
	'a3_right',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"f79c5c1d-cef3-4508-a2f4-0746f3bb4ac3",
	'');
INSERT INTO PE_PE
	VALUES ("49e18ad7-880a-4408-ae96-5847f0d7c717",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f3988409-4b26-4dcc-8768-3efcbf29844e",
	"00000000-0000-0000-0000-000000000000",
	'clear_select',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any var from instances of V_VAR
        where (selected.Var_ID == param.var_id );
if ( not_empty var )
  if ( not var.Declared )
    var.dispose();
  end if;
end if;


',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f25bda32-a650-4c5a-b9c1-ec0398e90919",
	"f3988409-4b26-4dcc-8768-3efcbf29844e",
	'var_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("f3988409-4b26-4dcc-8768-3efcbf29844e",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("756cd8a4-6d21-4abb-98b4-c3c39b438fa4",
	"00000000-0000-0000-0000-000000000000",
	'clear_rel_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'  if ( param.a3_where_val != GD::NULL_UNIQUE_ID() )
    select any val from instances of V_VAL
         where ( selected.Value_ID == param.a3_where_val );
    if ( not_empty val )
      val.dispose();
    end if;
  end if;

  if ( param.a2_chain_id != GD::NULL_UNIQUE_ID() )
    select any start_link from instances of ACT_LNK 
         where ( selected.Link_ID == param.a2_chain_id );
    if ( not_empty start_link )
      // follow links to the end, deleting along the way
      //  but don''t delete start_link yet
      next_id = start_link.Next_Link_ID;
      select any link from instances of ACT_LNK where ( selected.Link_ID == next_id );
      while ( not_empty link )
        last_link = link;
        select one link related by last_link->ACT_LNK[R604.''precedes''];
        last_link.dispose();
      end while;

      //  follow links back to beginning, deleting along the way
      link = start_link;
      while ( not_empty link )
        this_link = link;
        select one link related by this_link->ACT_LNK[R604.''succeeds''];
        this_link.dispose();
      end while;
    end if;
  end if;

  if ( param.a1_chain_start_val != GD::NULL_UNIQUE_ID() )
    select any val from instances of V_VAL where ( selected.Value_ID == param.a1_chain_start_val );
    if ( not_empty val )
      val.dispose();
     end if;
  end if;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("11d9ac2a-d814-4da0-b965-c7991408da19",
	"756cd8a4-6d21-4abb-98b4-c3c39b438fa4",
	'a1_chain_start_val',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("6f4e2e04-f150-45b1-ad76-7102db78dd3f",
	"756cd8a4-6d21-4abb-98b4-c3c39b438fa4",
	'a2_chain_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"11d9ac2a-d814-4da0-b965-c7991408da19",
	'');
INSERT INTO S_SPARM
	VALUES ("673f2e38-7a0a-4130-8a6e-64147d1facf6",
	"756cd8a4-6d21-4abb-98b4-c3c39b438fa4",
	'a3_where_val',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"6f4e2e04-f150-45b1-ad76-7102db78dd3f",
	'');
INSERT INTO PE_PE
	VALUES ("756cd8a4-6d21-4abb-98b4-c3c39b438fa4",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5ca24867-7d0b-41d1-9b11-6908f814a6a3",
	"00000000-0000-0000-0000-000000000000",
	'clear_for_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any iter from instances of V_VAR where ( selected.Var_ID == param.a1_iter );
if ( not_empty iter and not iter.Declared )
  iter.dispose();
end if;

select any for_blk from instances of ACT_BLK where (selected.Block_ID == param.a2_block);
if ( not_empty for_blk )
  for_blk.dispose();
end if;

select any stmt from instances of ACT_SMT
          where ( selected.Statement_ID == param.a3_stmt_id );
if ( not_empty stmt )
  stmt.dispose();
end if;






















































',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e5b32c52-4049-4ada-a5b5-227c0fb61c89",
	"5ca24867-7d0b-41d1-9b11-6908f814a6a3",
	'a1_iter',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f75fe0ef-a318-419e-a69f-9b042f78223d",
	"5ca24867-7d0b-41d1-9b11-6908f814a6a3",
	'a2_block',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"e5b32c52-4049-4ada-a5b5-227c0fb61c89",
	'');
INSERT INTO S_SPARM
	VALUES ("17550fc7-ab07-48ae-be2c-883d1df62ad7",
	"5ca24867-7d0b-41d1-9b11-6908f814a6a3",
	'a3_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"f75fe0ef-a318-419e-a69f-9b042f78223d",
	'');
INSERT INTO PE_PE
	VALUES ("5ca24867-7d0b-41d1-9b11-6908f814a6a3",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c9d8c80-432b-467e-97c3-5c094f99b429",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_bridge',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  select one package related by containingElem->EP_PKG[R8001];

  // Check for EE keyletter match for token
  if not_empty component
    component.collectVisibleElementsForName(name:param.key_lett,
         type:ElementTypeConstants::EE, originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  else
    package.collectVisibleElementsForName(name:param.key_lett,
         type:ElementTypeConstants::EE, descending:false,
                           originatingContainerID:containingElem.Element_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
  end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == param.key_lett and 
                                      selected.Type == ElementTypeConstants::EE; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
  if not_empty package
    select any pkgResultSet related by package->PE_SRS[R8005] where
                                    selected.Name == param.key_lett and 
                                      selected.Type == ElementTypeConstants::EE; 
    select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
  end if;
  if empty results
    ERR::reportParseError( 
        msg: "Cannot find external entity ->"+param.key_lett+"<-", 
                                                      token: param.rule_token ); 
  else  // results not empty
    // select the first ee in the result set (it is acceptable to have multiple
    // ees and we only want to validate multiple bridges in the same ee)
    select any ee related by results->S_EE[R8001];
    select many brg_set related by ee->S_BRG[R19]
                                              where selected.Name == param.name;
    if ( empty brg_set )
      ERR::reportParseError( 
          msg: "Cannot find specified bridge ->"+param.key_lett+"::%s<-", 
                                                      token: param.rule_token ); 
    elif ( cardinality brg_set > 1 )
      ERR::reportParseError(msg: "More than one bridge with name ->%s<- " +
          "You will need to eventually clear this up", token: param.rule_token);
    else // cardinality brg_set == 1
      select any brg related by results->S_EE[R8001]->S_BRG[R19]
                                              where selected.Name == param.name;
      create object instance brv of V_BRV;
      brv.ParmListOK = true;
      create object instance val of V_VAL;
      relate val to block across R826;
      relate val to brv across R801;

      val.LineNumber = ::getLineNumber(rule_token: param.rule_token);
      val.StartPosition = ::getColumn(rule_token: param.rule_token);
      val.setEndPosition();

      // store the textual position of the external entity key-letters
      brv.externalEntityKeyLettersLineNumber =
                                              block.currentKeyLettersLineNumber;
      brv.externalEntityKeyLettersColumn = block.currentKeyLettersColumn;

      relate brg to brv across R828;
      select one bdt related by brg->S_DT[R20];
      relate val to bdt across R820;

      return val.Value_ID;
    end if;
  end if;
  return GD::NULL_UNIQUE_ID();
else  // non-generic package path
  select any ee from instances of S_EE where
                                            selected.Key_Lett == param.key_lett;
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];

    ERR::reportParseError( 
        msg: "Cannot find specified bridge ->"+ee.Key_Lett+"::%s<-", 
        token: param.rule_token ); 
  return GD::NULL_UNIQUE_ID();
end if;',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("505c2939-4c42-4fd1-801e-b2fe7d2ec851",
	"1c9d8c80-432b-467e-97c3-5c094f99b429",
	'key_lett',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("10241884-d071-4f46-8f79-a1d39cc4c5ae",
	"1c9d8c80-432b-467e-97c3-5c094f99b429",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"505c2939-4c42-4fd1-801e-b2fe7d2ec851",
	'');
INSERT INTO S_SPARM
	VALUES ("cfb33c96-f243-4eba-bd61-57efc160d979",
	"1c9d8c80-432b-467e-97c3-5c094f99b429",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"10241884-d071-4f46-8f79-a1d39cc4c5ae",
	'');
INSERT INTO PE_PE
	VALUES ("1c9d8c80-432b-467e-97c3-5c094f99b429",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_transform',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any obj from instances of O_OBJ where ( selected.Obj_ID == param.a1_obj_id ); 
select many tfr_set related by obj->O_TFR[R115] where selected.Name == param.a2_name;
if ( empty tfr_set )
   ERR::reportParseError( 
        msg: "Cannot find specified operation ->"+obj.Key_Lett+"::%s<-", 
        token: param.a3_rule_token ); 
elif ( cardinality tfr_set > 1 )
   ERR::reportParseError( msg:
"More than one operation with name ->%s<- You will need to eventually run the audit and/or clear this up",
          token: param.a3_rule_token );
else
  select any tfr related by obj->O_TFR[R115] where selected.Name == param.a2_name;
  if ( tfr.Instance_Based == Scope::Instance and param.a4_classBased )
    ERR::reportParseError( 
       msg: "Operation ->%s<- is instance-based and must be invoked as <var>."+param.a2_name,
        token: param.a3_rule_token ); 
  elif ( tfr.Instance_Based == Scope::Class and not param.a4_classBased )
    ERR::reportParseError( 
       msg: "Operation ->%s<- is class-based and must be invoked as <kl>::"+param.a2_name,
        token: param.a3_rule_token ); 
  else
    create object instance trv of V_TRV;
    trv.ParmListOK = true;
    create object instance val of V_VAL;
    current_scope = ::get_current_scope();
    select any block from instances of ACT_BLK where (selected.Block_ID == current_scope);
    relate val to block across R826;
    relate val to trv across R801;

    relate tfr to trv across R829;
    select one tdt related by tfr->S_DT[R116];
    relate val to tdt across R820;

    val.LineNumber = ::getLineNumber(rule_token: param.a3_rule_token);
    val.StartPosition = ::getColumn(rule_token: param.a3_rule_token);
    val.setEndPosition();

	// if the operation is class-based
	if (tfr.Instance_Based == Scope::Class)
		// store the textual position of the class key-letters
		trv.modelClassKeyLettersLineNumber = block.currentKeyLettersLineNumber;
		trv.modelClassKeyLettersColumn = block.currentKeyLettersColumn;
	end if;

    return val.Value_ID;
  end if;
end if;

return GD::NULL_UNIQUE_ID();







































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("efb7ec6d-b37a-46f4-813e-bbe3fdaf57c1",
	"1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	'a1_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("eafe3b43-b1af-48e6-9dda-052095513e80",
	"1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	'a2_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"efb7ec6d-b37a-46f4-813e-bbe3fdaf57c1",
	'');
INSERT INTO S_SPARM
	VALUES ("ba605e34-e281-4c71-946d-675c29747cfe",
	"1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"eafe3b43-b1af-48e6-9dda-052095513e80",
	'');
INSERT INTO S_SPARM
	VALUES ("9dc91b81-6866-41b0-82f2-6da83e55d4c9",
	"1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	'a4_classBased',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"ba605e34-e281-4c71-946d-675c29747cfe",
	'');
INSERT INTO PE_PE
	VALUES ("1b6ea7bc-4de0-426d-9d3d-e616e4b65bf7",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3dc06f4d-e524-4383-aa12-75da2d312c65",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_invocation',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// ::is_valid_invocation()
if ( param.a2_isRval )
  if ( param.a1_type == "void" )
    select any val from instances of V_VAL where
                                               selected.Value_ID == param.a3_id;
    if ( not_empty val )
      val.dispose();
    end if;
    ERR::reportParseError( msg: param.a4_name +
          "<- has no return type (return type is void) and " +
                                  "thus cannot be used in an expression",  
                                                   token: param.a5_rule_token );
  end if;
else
  if ( param.a1_type != "void" )
    select any val from instances of V_VAL where
                                               selected.Value_ID == param.a3_id;
    if ( not_empty val )
      val.dispose();
    end if;
    ERR::reportParseError( msg: param.a4_name +
          "<- has a return value which is not being assigned to a variable",
          token: param.a5_rule_token );
  end if;
end if;
return param.a3_id;



































',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d779cb4a-2d60-484a-9fe5-e0df00ac0651",
	"3dc06f4d-e524-4383-aa12-75da2d312c65",
	'a1_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("436813c3-d02f-4bd6-b1e7-d80850108748",
	"3dc06f4d-e524-4383-aa12-75da2d312c65",
	'a2_isRval',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"d779cb4a-2d60-484a-9fe5-e0df00ac0651",
	'');
INSERT INTO S_SPARM
	VALUES ("f1111eb2-47c8-46c8-95b5-a11cb021ebfb",
	"3dc06f4d-e524-4383-aa12-75da2d312c65",
	'a3_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"436813c3-d02f-4bd6-b1e7-d80850108748",
	'');
INSERT INTO S_SPARM
	VALUES ("62518d67-00e6-4027-ae62-78058ffb77d1",
	"3dc06f4d-e524-4383-aa12-75da2d312c65",
	'a4_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f1111eb2-47c8-46c8-95b5-a11cb021ebfb",
	'');
INSERT INTO S_SPARM
	VALUES ("27a09596-b3c6-4cad-87fa-11946930765a",
	"3dc06f4d-e524-4383-aa12-75da2d312c65",
	'a5_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"62518d67-00e6-4027-ae62-78058ffb77d1",
	'');
INSERT INTO PE_PE
	VALUES ("3dc06f4d-e524-4383-aa12-75da2d312c65",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b9c4a5d3-580c-4835-bffc-e43a565246c4",
	"00000000-0000-0000-0000-000000000000",
	'statement_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
if ( not_empty blk )
  create object instance stmt of ACT_SMT;
  relate blk to stmt across R602;

  return stmt.Statement_ID;
end if;
return GD::NULL_UNIQUE_ID();






',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b9c4a5d3-580c-4835-bffc-e43a565246c4",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5a23c2b4-6e56-4d14-9278-5c91bf88213c",
	"00000000-0000-0000-0000-000000000000",
	'is_readonly_value',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any val from instances of V_VAL where selected.Value_ID == param.val_id;

// there are fewer read-write value types
select one tvl related by val->V_TVL[R801];
if ( not_empty tvl )
  return false;
end if;

select one avl related by val->V_AVL[R801];
if ( not_empty avl )
  return false;
end if;

select one irf related by val->V_IRF[R801];
if ( not_empty irf )
  return false;
end if;

select one isr related by val->V_ISR[R801];
if ( not_empty isr )
  return false;
end if;

select one pvl related by val->V_PVL[R801];
if ( not_empty pvl )
  select one bparm related by pvl->S_BPARM[R831];
  if ( not_empty bparm )
    return bparm.By_Ref == 0;
  end if;
  select one sparm related by pvl->S_SPARM[R832];
  if ( not_empty sparm )
    return sparm.By_Ref == 0;
  end if;
  select one tparm related by pvl->O_TPARM[R833];
  if ( not_empty tparm )
    return tparm.By_Ref == 0;
  end if;
end if;


return true;

',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a6b5ca44-63c7-47d3-a0b8-09e6b69e41c6",
	"5a23c2b4-6e56-4d14-9278-5c91bf88213c",
	'val_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("5a23c2b4-6e56-4d14-9278-5c91bf88213c",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4313093b-a0a6-4309-a53d-e5d47f5a397b",
	"00000000-0000-0000-0000-000000000000",
	'search_supertypes_for_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any sub_sm from instances of SM_SM where selected.SM_ID == param.a1_subtype_sm;
if not_empty sub_sm
  select one obj related by sub_sm->SM_ISM[R517]->O_OBJ[R518];
  select many oir_set related by obj->R_OIR[R201];
  event_no_splat = OS::remove_star( s: param.a2_evt_name );
  for each oir in oir_set
    select one sub related by oir->R_RGO[R203]->R_SUB[R205];
    if not_empty sub
      // it''s a subtype in this association
      select one sup_obj related by sub->R_SUBSUP[R213]->
          R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201];
      if not_empty sup_obj
        select one sup_sm related by sup_obj->SM_ISM[R518]->SM_SM[R517];
        if not_empty sup_sm
          select any evt related by sup_sm->SM_EVT[R502] 
              where selected.Drv_Lbl == event_no_splat;
          if not_empty evt
            return sup_sm.SM_ID;
          else
            sm_id = ::search_supertypes_for_event( 
               a1_subtype_sm: sup_sm.SM_ID, a2_evt_name: event_no_splat);
            if ( sm_id != GD::NULL_UNIQUE_ID() )
              return sm_id;
            end if;
          end if;
        end if;
      end if;  // not_empty sup_obj
    end if;  // not_empty sub
  end for;
end if;

return GD::NULL_UNIQUE_ID();




















',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bee3b851-76ae-4136-98da-38546636e5dc",
	"4313093b-a0a6-4309-a53d-e5d47f5a397b",
	'a1_subtype_sm',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0775a6bb-9625-493b-9c65-b2b10e16acb9",
	"4313093b-a0a6-4309-a53d-e5d47f5a397b",
	'a2_evt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bee3b851-76ae-4136-98da-38546636e5dc",
	'');
INSERT INTO PE_PE
	VALUES ("4313093b-a0a6-4309-a53d-e5d47f5a397b",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ff364dfe-13ce-4715-8cd5-59f995ba491f",
	"00000000-0000-0000-0000-000000000000",
	'process_class_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

  select any sm from instances of SM_ASM 
      where selected.Obj_ID == param.a2_obj_id;
  select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
  if ( empty sm )
    stmt.dispose();
    select any obj from instances of O_OBJ 
        where selected.Obj_ID == param.a2_obj_id;
    ERR::reportParseError( msg: 
        "Cannot find Class State Machine for class ->"+
        obj.Name+"<-",   token: param.a3_rule_token );
  elif ( empty evt )
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    stmt.dispose();
    select one obj related by sm->O_OBJ[R519];
    ERR::reportParseError( msg: "Event ->"+eeevt.Drv_Lbl+
        "<- does not exist for class state machine of class ->"+obj.Name+"<-",
            token: param.a3_rule_token );
  else
    select one evt_sm related by evt->SM_SM[R502];
    if ( evt_sm.SM_ID != sm.SM_ID )
      stmt.dispose();
      select one obj related by sm->O_OBJ[R519];
      ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+
          "<- does not exist for class state machine of class ->"+obj.Name+"<-",
              token: param.a3_rule_token );
    else
      if ( ess.PEIndicated )
        // non-polymorphic event with *
        stmt.dispose();
        ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''.",
               token: param.a3_rule_token );
      else
        edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: evt_sm.SM_ID,
            a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );
        if ( edi_ok )   
          select one gsme related by ges->E_GSME[R703];
          create object instance gar of E_GAR;
          relate gar to gsme across R705;
          return stmt.Statement_ID;
        end if;
      end if;
    end if;
  end if;
return GD::NULL_UNIQUE_ID();
',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9448f09a-14e7-46ba-9133-41c23de3350a",
	"ff364dfe-13ce-4715-8cd5-59f995ba491f",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("65d9b121-0513-4371-85b6-4e5ac47c5ae8",
	"ff364dfe-13ce-4715-8cd5-59f995ba491f",
	'a2_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"9448f09a-14e7-46ba-9133-41c23de3350a",
	'');
INSERT INTO S_SPARM
	VALUES ("5529ca9d-c9cd-4903-a84d-74f64be6cb98",
	"ff364dfe-13ce-4715-8cd5-59f995ba491f",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"65d9b121-0513-4371-85b6-4e5ac47c5ae8",
	'');
INSERT INTO PE_PE
	VALUES ("ff364dfe-13ce-4715-8cd5-59f995ba491f",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6c40a1e3-da8c-4a9c-808c-d37a2d9ac13d",
	"00000000-0000-0000-0000-000000000000",
	'process_creation_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

  select any sm from instances of SM_ISM 
      where selected.Obj_ID == param.a2_obj_id;
  select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
  if ( empty evt )
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    stmt.dispose();
    select one obj related by sm->O_OBJ[R518];
    ERR::reportParseError( msg: "Event ->"+eeevt.Drv_Lbl+
          "<- does not exist for class ->"+obj.Name+"<-",
            token: param.a3_rule_token );
  else
    select one evt_sm related by evt->SM_SM[R502];
    if ( evt_sm.SM_ID != sm.SM_ID )
      stmt.dispose();
      select one obj related by sm->O_OBJ[R518];
      ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+
              "<- is not a creation transition for class ->"+obj.Name+"<-",
              token: param.a3_rule_token );
    else
      select one levt related by evt->SM_SEVT[R525]->SM_LEVT[R526];
      if ( empty levt )
        stmt.dispose();
        select one obj related by sm->O_OBJ[R518];
        ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+ 
              "<- is not a creation transition for class ->"+obj.Name+"<-",
                token: param.a3_rule_token );
      else
        select one crtxn related by levt->SM_CRTXN[R509];
        if ( empty crtxn )
          stmt.dispose();
          select one obj related by sm->O_OBJ[R518];
          ERR::reportParseError( msg: "Event ->"+evt.Drv_Lbl+ 
                "<- is not a creation transition for class ->"+obj.Name+"<-",
                  token: param.a3_rule_token );
        else
          if ( ess.PEIndicated )
            // non-polymorphic event with *
            stmt.dispose();
            ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''.",
               token: param.a3_rule_token );
          else
            edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: evt_sm.SM_ID,
                a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );
            if ( edi_ok )   
              select one gsme related by ges->E_GSME[R703];
              create object instance gec of E_GEC;
              relate gec to gsme across R705;
              return stmt.Statement_ID;
            end if;  // edi_ok
          end if;  // ess.PEIndicated
        end if;  // empty crtxn
      end if;  // empty levt
    end if;  // evt_sm.SM_ID != sm.SM_ID
  end if; // empty evt
return GD::NULL_UNIQUE_ID();


















',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a3c92566-15eb-47de-baab-b6f697b9adb3",
	"6c40a1e3-da8c-4a9c-808c-d37a2d9ac13d",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("b31627e0-b939-47ef-9a71-22e8a177c06f",
	"6c40a1e3-da8c-4a9c-808c-d37a2d9ac13d",
	'a2_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"a3c92566-15eb-47de-baab-b6f697b9adb3",
	'');
INSERT INTO S_SPARM
	VALUES ("7b7410c5-84f4-4896-bf2d-f0af2ad12080",
	"6c40a1e3-da8c-4a9c-808c-d37a2d9ac13d",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"b31627e0-b939-47ef-9a71-22e8a177c06f",
	'');
INSERT INTO PE_PE
	VALUES ("6c40a1e3-da8c-4a9c-808c-d37a2d9ac13d",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1d515b43-5de1-42c0-9f12-334a08a9d856",
	"00000000-0000-0000-0000-000000000000",
	'process_instance_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

select any var from instances of V_VAR where ( selected.Var_ID == param.a2_var_id );
select one obj related by var->V_INT[R814]->O_OBJ[R818];
select one ism related by obj->SM_ISM[R518];
select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
if ( empty ism )
  stmt.dispose();
  ERR::reportParseError( msg: 
    "Cannot find Instance State Machine for class ->"+
      obj.Name+"<-",   token: param.a3_rule_token );
elif ( empty evt )
  select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
  stmt.dispose();
  select one obj related by ism->O_OBJ[R518];
  ERR::reportParseError( msg: "Cannot find event ->"+ eeevt.Drv_Lbl +
          "<- for class ->"+obj.Name+"<-",   token: param.a3_rule_token );
else
  select one evt_sm related by evt->SM_SM[R502];
  if ( evt_sm.SM_ID != ism.SM_ID )
    sm_id = ::search_supertypes_for_event( 
         a1_subtype_sm: ism.SM_ID, a2_evt_name: evt.Drv_Lbl );
    if ( sm_id == GD::NULL_UNIQUE_ID() )
      stmt.dispose();
      select one obj related by ism->O_OBJ[R518];
      ERR::reportParseError( msg: "Cannot find event ->"+ evt.Drv_Lbl +
               "<- for class ->"+obj.Name+"<-",   token: param.a3_rule_token );
    else
      if ( not ess.PEIndicated )
        // polymorphic event without * -- not a problem re-render will add
      end if;
      
      select one polyEvent related by evt->SM_PEVT[R525]; 
      if ( empty polyEvent)
      	ERR::reportParseError( msg: "Supertype event ->" + evt.Drv_Lbl + "<- is not polymorphic",
      					token: param.a3_rule_token);
      end if;
      
      select any sm from instances of SM_SM where selected.SM_ID == sm_id;
      select one ism related by sm->SM_ISM[R517];
    end if;
  else
    if ( ess.PEIndicated )
      // determine if event is polymorphic
      select one pevt related by evt->SM_PEVT[R525];
      if ( empty pevt )
        // non-polymorphic event with *
        stmt.dispose();
        ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''.",
             token: param.a3_rule_token );
      end if;
    end if;
  end if;
end if;

edi_ok = ::is_valid_sm_event_data( a1_stmt_id: param.a1_stmt_id, a2_sm_id: ism.SM_ID,
        a3_smevt_id: evt.SMevt_ID, a4_rule_token: param.a3_rule_token );

if ( edi_ok )   
  select one gsme related by ges->E_GSME[R703];
  create object instance gen of E_GEN;
  relate gsme to gen across R705;
  relate gen to var across R712;
  return stmt.Statement_ID;
end if;
return GD::NULL_UNIQUE_ID();




















',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f1c3c344-c080-42d7-8921-6908889a5a7b",
	"1d515b43-5de1-42c0-9f12-334a08a9d856",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("dda37196-e2de-4154-a4dc-8305f21eaee3",
	"1d515b43-5de1-42c0-9f12-334a08a9d856",
	'a2_var_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"f1c3c344-c080-42d7-8921-6908889a5a7b",
	'');
INSERT INTO S_SPARM
	VALUES ("3c69f931-4176-4de1-9d1f-8bc3a904e5fe",
	"1d515b43-5de1-42c0-9f12-334a08a9d856",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"dda37196-e2de-4154-a4dc-8305f21eaee3",
	'');
INSERT INTO PE_PE
	VALUES ("1d515b43-5de1-42c0-9f12-334a08a9d856",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("73e8a2c9-154f-4eb3-8233-79b7f21ae424",
	"00000000-0000-0000-0000-000000000000",
	'process_ee_event',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
    where selected.Statement_ID == param.a1_stmt_id;
select one ess related by stmt->E_ESS[R603];
select one ges related by ess->E_GES[R701];

    select any ee from instances of S_EE 
         where ( selected.EE_ID == param.a2_ee_id );
    select one eeevt related by ges->E_GEE[R703]->S_EEEVT[R709];
    if ( empty eeevt )
      select one evt related by ges->E_GSME[R703]->SM_EVT[R707];
      stmt.dispose();
      ERR::reportParseError( msg: "Cannot find event for event label ->"+evt.Drv_Lbl+
            "<- for external entity ->"+ee.Name+"<-",
                token: param.a3_rule_token );
    else
      if ( eeevt.EE_ID != ee.EE_ID )
        stmt.dispose();
        ERR::reportParseError( msg: "Cannot find event for event label ->"+eeevt.Drv_Lbl+
              "<- for external entity ->"+ee.Name+"<-",
                  token: param.a3_rule_token );
      else
        if ( ess.PEIndicated )
          // non-polymorphic event with *
          stmt.dispose();
          ERR::reportParseError( msg: "Event is not a polymorphic event. Event label must not contain ''*''.",
               token: param.a3_rule_token );
       else
         edi_ok = ::is_valid_ee_event_data( a1_stmt_id: param.a1_stmt_id, a2_ee_id: ee.EE_ID,
              a3_evt_id: eeevt.EEevt_ID, a4_rule_token: param.a3_rule_token );
          if ( edi_ok )
           return stmt.Statement_ID;
         end if;
       end if;
      end if;
    end if;
return GD::NULL_UNIQUE_ID();


















',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4a7b6cb2-016c-40d7-a126-354e88947ebd",
	"73e8a2c9-154f-4eb3-8233-79b7f21ae424",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("413d292b-5108-464b-b7e4-cafa20f9e578",
	"73e8a2c9-154f-4eb3-8233-79b7f21ae424",
	'a2_ee_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"4a7b6cb2-016c-40d7-a126-354e88947ebd",
	'');
INSERT INTO S_SPARM
	VALUES ("b3ea65fa-e0c1-4a17-95f2-8ffd1074ac69",
	"73e8a2c9-154f-4eb3-8233-79b7f21ae424",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"413d292b-5108-464b-b7e4-cafa20f9e578",
	'');
INSERT INTO PE_PE
	VALUES ("73e8a2c9-154f-4eb3-8233-79b7f21ae424",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_sm_event_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any ess from instances of E_ESS where
                                      selected.Statement_ID == param.a1_stmt_id;
if not ess.ParmListOK
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  return false;
end if;
select many parm_set related by ess->V_PAR[R700];
select any sm from instances of SM_SM where selected.SM_ID == param.a2_sm_id;
select any evt related by sm->SM_EVT[R502] where
                                         selected.SMevt_ID == param.a3_smevt_id;
select many edi_set related by evt->SM_EVTDI[R532];
for each edi in edi_set
  select many dups related by evt->SM_EVTDI[R532] where
                                                      selected.Name == edi.Name;
  if ( cardinality dups > 1 )
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "More than one parameter with name ->" +
                                   edi.Name +"<-", token: param.a4_rule_token );
  end if;
end for;
if cardinality parm_set <= cardinality edi_set
  for each edi in edi_set
    found = false;
    for each parm in parm_set
      if ( parm.Name == edi.Name )
        found = true;
        err_msg = "";
        select one parm_val related by parm->V_VAL[R800];
        select one parm_dt related by parm_val->S_DT[R820];
        if (empty parm_dt)
          err_msg = "Parameter ->"+ parm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: edi.DT_ID, dt2: parm_dt.DT_ID,
                                        op: "assign")  == GD::NULL_UNIQUE_ID() )
          err_msg = "Parameter ->"+ parm.Name + "<- has been assigned value of different type";
        end if;
        if (edi.getDimensionsCnt()!= parm_val.getDimensions())
          err_msg = "Parameter ->" + edi.Name + "<- has incompatible array depth.";
        elif ( not parm_val.isElementCountValid() )
          err_msg = "Parameter ->"+ edi.Name +"<- contains an Array Index Out of Bounds.";
        end if;
        if (err_msg == "")
          break;
        else 
          select one stmt related by ess->ACT_SMT[R603];
          stmt.dispose();        
          ERR::reportParseError( msg: err_msg, token: param.a4_rule_token  );
        end if;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "State machine event with label ->" +
                  evt.Drv_Lbl + "<- is missing corresponding parameter ->" +
                                  edi.Name + "<-", token: param.a4_rule_token );
    end if;
  end for;

  // If execution gets here, all the data items from the database
  // were found in the parse data items.

else // cardinality parm_set > cardinality edi_set

  // If there are more data items in the parse then were found in the
  // database, that means there were redundant or extra data items in the
  // parameter list found by the parse.  Generate an error.

  for each parm in parm_set
    found = false;
    for each edi in edi_set
      if ( parm.Name == edi.Name )
        found = true;
        break;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
            "<- is not associated with state machine event with label ->" +
                               evt.Drv_Lbl + "<-", token: param.a4_rule_token );
    end if;
  end for;

  // If it gets out of the loop without error, there must be
  // a redundant data item, so report the error
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  ERR::reportParseError( msg: "State machine event with label ->" +
                               evt.Drv_Lbl+ "<- has redundant parameters",
                                                   token: param.a4_rule_token );
  return false;
end if;
return true;',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e4882c5e-23ce-4c3f-877a-550e17ed8bf3",
	"62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("1d359244-9ef3-4b6c-8843-751585dc25e5",
	"62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	'a2_sm_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"e4882c5e-23ce-4c3f-877a-550e17ed8bf3",
	'');
INSERT INTO S_SPARM
	VALUES ("3939c178-885e-40ff-b3b9-9f4a48199d8f",
	"62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	'a3_smevt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"1d359244-9ef3-4b6c-8843-751585dc25e5",
	'');
INSERT INTO S_SPARM
	VALUES ("5aaa10a0-b132-4500-a499-c0ae7a49b5c8",
	"62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	'a4_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"3939c178-885e-40ff-b3b9-9f4a48199d8f",
	'');
INSERT INTO PE_PE
	VALUES ("62cd32c2-b74b-4259-b6a9-f2c30ef583ee",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("145dddd0-ce6d-48b5-9c02-f25892735da8",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_ee_event_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any ess from instances of E_ESS where selected.Statement_ID == param.a1_stmt_id;
if not ess.ParmListOK
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  return false;
end if;

select many parm_set related by ess->V_PAR[R700];

select any ee from instances of S_EE where selected.EE_ID == param.a2_ee_id;
select any evt related by ee->S_EEEVT[R10] where selected.EEevt_ID == param.a3_evt_id;
select many edi_set related by evt->S_EEEDT[R13]->S_EEEDI[R13];

// first check that there are no duplicated data items
for each edi in edi_set
  select many dups related by ee->S_EEEDI[R12] where selected.Name == edi.Name;
  if ( cardinality dups > 1 )
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "More than one parameter with name ->"+ edi.Name +
             "<- You will need to eventually run the audit and/or clear this up",
              token: param.a4_rule_token );
  end if;
end for;

if ( cardinality parm_set < cardinality edi_set )
  select one stmt related by ess->ACT_SMT[R603];
  stmt.dispose();
  ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
      "<- is missing some parameters",
          token: param.a4_rule_token );
else
  for each edi in edi_set
    found = false;
    for each parm in parm_set
      if ( parm.Name == edi.Name )
        found = true;
        select one parm_dt related by parm->V_VAL[R800]->S_DT[R820];
        if (empty parm_dt)
          err_msg = "Parameter ->"+ parm.Name +"<- value has an unknown data type.";
        elif ( ::data_types_compatible( dt1: edi.DT_ID, dt2: parm_dt.DT_ID, op: "assign")  == GD::NULL_UNIQUE_ID() )
          select one stmt related by ess->ACT_SMT[R603];
          stmt.dispose();
          ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
             "<- has been assigned value of different type",
              token: param.a4_rule_token );
        end if;
        break;
      end if;
    end for;
    if ( not found )
      select one stmt related by ess->ACT_SMT[R603];
      stmt.dispose();
      ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
          "<- is missing corresponding parameter(s)",
             token: param.a4_rule_token );
      break;
    end if;
  end for;
end if;

      // If execution gets here, all the data items from the database
      // were found in the parse data items.

      // If there are more data items in the parse then were found in the
      // database, that means there were redundant or extra data items in the
      // parameter list found by the parse.  Generate an error.

  if ( cardinality parm_set > cardinality edi_set )
    for each parm in parm_set
      found = false;
      for each edi in edi_set
        if ( parm.Name == edi.Name )
          found = true;
          break;
        end if;
      end for;
      if ( not found )
        select one stmt related by ess->ACT_SMT[R603];
        stmt.dispose();
        ERR::reportParseError( msg: "Parameter ->"+ parm.Name +
          "<- is not associated with external entity event with label ->"+evt.Drv_Lbl+"<-",
             token: param.a4_rule_token );
      end if;
    end for;

      // If it gets out of the loop without error, there must be
      // a redundant data item, so report the error
    select one stmt related by ess->ACT_SMT[R603];
    stmt.dispose();
    ERR::reportParseError( msg: "External entity event with label ->"+evt.Drv_Lbl+
      "<- has redundant parameters",
          token: param.a4_rule_token );
    return false;
  end if;

return true;

















',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f15c1484-bc00-458c-b661-82ca71940c1f",
	"145dddd0-ce6d-48b5-9c02-f25892735da8",
	'a1_stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("fe902352-3a1f-49e3-a74c-ec1871efa61f",
	"145dddd0-ce6d-48b5-9c02-f25892735da8",
	'a2_ee_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"f15c1484-bc00-458c-b661-82ca71940c1f",
	'');
INSERT INTO S_SPARM
	VALUES ("fee0985c-dbf7-4ac0-a11c-2f4b5e0db82c",
	"145dddd0-ce6d-48b5-9c02-f25892735da8",
	'a3_evt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"fe902352-3a1f-49e3-a74c-ec1871efa61f",
	'');
INSERT INTO S_SPARM
	VALUES ("4117f86d-bf67-42dd-b1b0-6bcdd4a47a96",
	"145dddd0-ce6d-48b5-9c02-f25892735da8",
	'a4_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"fee0985c-dbf7-4ac0-a11c-2f4b5e0db82c",
	'');
INSERT INTO PE_PE
	VALUES ("145dddd0-ce6d-48b5-9c02-f25892735da8",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f5f8b0a0-4e9f-4de9-8a69-5d90bc3fbc40",
	"00000000-0000-0000-0000-000000000000",
	'clear_assignment_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any stmt from instances of ACT_SMT 
     where ( selected.Statement_ID == param.stmt_id );
if ( not_empty stmt )
  stmt.dispose();
end if;

if (  param.var_id != GD::NULL_UNIQUE_ID() )
  select any var from instances of V_VAR where selected.Var_ID == param.var_id;
  if ( not_empty var )
    if ( not var.Declared )
      var.dispose();
    end if;
  end if;
end if;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7883a0c5-8fee-41ea-a34f-c7a44e1c1243",
	"f5f8b0a0-4e9f-4de9-8a69-5d90bc3fbc40",
	'stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a8eee273-d1a7-4b94-9fb3-f9ca2923b922",
	"f5f8b0a0-4e9f-4de9-8a69-5d90bc3fbc40",
	'var_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"7883a0c5-8fee-41ea-a34f-c7a44e1c1243",
	'');
INSERT INTO PE_PE
	VALUES ("f5f8b0a0-4e9f-4de9-8a69-5d90bc3fbc40",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("69c234c0-79b8-4bfa-a24e-036c363f86db",
	"00000000-0000-0000-0000-000000000000",
	'self_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'if ( param.a1_text == "SELF" or param.a1_text == "Self" or param.a1_text == "self" )
  current_scope = ::get_current_scope();
  select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
  select one act related by blk->ACT_ACT[R612];
  if ( not act.self_is_valid() )
    err_msg =  "Keyword ->%s<- cannot be used in " + act.Type +
                                                          " AL specifications.";
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg,
        token: param.a3_token );
  else
    if ( param.a2_isLval )
      ::clear_value_data();
      ERR::reportParseError( msg: "Cannot assign a value to ->%s<-.",
                                                        token: param.a3_token );
    else
      var_id = ::get_var_in_scope( name: param.a1_text, rule_token: param.a3_token );
      if ( var_id == GD::NULL_UNIQUE_ID() )
        select one outer_blk related by act->ACT_BLK[R650];
        create object instance slf of V_INT;
        create object instance var_inst of V_VAR;
        relate var_inst to slf across R814;
        var_inst.Name = param.a1_text;
        relate var_inst to outer_blk across R823;
        select one op related by act->ACT_OPB[R698] ->O_TFR[R696];
        if ( not_empty op )
          select one obj related by op->O_OBJ[R115];
          relate obj to slf across R818;
          ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
        else
          select one sm_act related by act->ACT_SAB[R698]->SM_ACT[R691];
          if ( not_empty sm_act )
            // State action case
            select one obj related by sm_act->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
            if not_empty obj
              relate obj to slf across R818;
              ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
            end if;
          else
            select one sm_act related by act->ACT_TAB[R698]->SM_ACT[R688];
            if ( not_empty sm_act )
              // Transition action case
              select one obj related by sm_act->SM_SM[R515]->SM_ISM[R517]->O_OBJ[R518];
              if not_empty obj
                relate obj to slf across R818;
                ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
              end if;
            else
              select one dab related by act->ACT_DAB[R698]->O_DBATTR[R693];
              select one obj related by dab->O_BATTR[R107]->O_ATTR[R106]->O_OBJ[R102];
              relate obj to slf across R818;
              ::connect_inst_ref_var_to_datatype(p1_is_set:false, p2_var_id:var_inst.Var_ID, p3_obj_id:obj.Obj_ID);
            end if;
          end if;
        end if;
        var_inst.Declared = true;
      end if;  // var_id == GD::NULL_UNIQUE_ID
   end if;  // param.isLval
  end if;  // not act.SelfIsValid
end if;  // if param.text == "SELF" ...',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("590a53a3-ebd8-4d35-bff4-1b69684142b7",
	"69c234c0-79b8-4bfa-a24e-036c363f86db",
	'a1_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("8ac70289-23b5-4758-ab56-b553dee396f8",
	"69c234c0-79b8-4bfa-a24e-036c363f86db",
	'a2_isLval',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"590a53a3-ebd8-4d35-bff4-1b69684142b7",
	'');
INSERT INTO S_SPARM
	VALUES ("86b7a7d1-ee94-439d-bd1b-864318745a81",
	"69c234c0-79b8-4bfa-a24e-036c363f86db",
	'a3_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"8ac70289-23b5-4758-ab56-b553dee396f8",
	'');
INSERT INTO PE_PE
	VALUES ("69c234c0-79b8-4bfa-a24e-036c363f86db",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b8b8c136-2170-42bb-a011-ff2cf338b0f4",
	"00000000-0000-0000-0000-000000000000",
	'get_current_context',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'return m_act_id;






',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'');
INSERT INTO PE_PE
	VALUES ("b8b8c136-2170-42bb-a011-ff2cf338b0f4",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f8869431-cf05-4fc8-887c-eee6834e9f5d",
	"00000000-0000-0000-0000-000000000000",
	'set_current_context',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'm_act_id = p_Context;






',
	"ba5eda7a-def5-0000-0000-000000000000",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("350b3817-e3e6-486c-8dc1-9c9c5ad4b8e2",
	"f8869431-cf05-4fc8-887c-eee6834e9f5d",
	'context',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("f8869431-cf05-4fc8-887c-eee6834e9f5d",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a842e4fb-9637-4631-acc5-1168ca1dda52",
	"00000000-0000-0000-0000-000000000000",
	'getLineNumber',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'if ( p_Rule_token != null )
  return p_Rule_token.getLine();
else
  return -1;

',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("3ea5b932-b4f4-4305-b8f5-c5adfb0770ca",
	"a842e4fb-9637-4631-acc5-1168ca1dda52",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("a842e4fb-9637-4631-acc5-1168ca1dda52",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c1c0b7f8-c184-4a0f-98c3-354ad4f97291",
	"00000000-0000-0000-0000-000000000000",
	'getColumn',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'if ( p_Rule_token != null )
  return p_Rule_token.getColumn();
else
  return -1;

',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("ec8c1c94-173f-4543-a899-6a319fd56c0d",
	"c1c0b7f8-c184-4a0f-98c3-354ad4f97291",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("c1c0b7f8-c184-4a0f-98c3-354ad4f97291",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5e7aad81-299e-4272-acb6-13356336429a",
	"00000000-0000-0000-0000-000000000000",
	'rememberLocation',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where (selected.Block_ID == current_scope);
blk.CurrentLine = ::getLineNumber(rule_token: param.rule_token);
blk.CurrentCol = ::getColumn(rule_token: param.rule_token);

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6e61483d-f8ca-4476-a0c4-119ba625da37",
	"5e7aad81-299e-4272-acb6-13356336429a",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("5e7aad81-299e-4272-acb6-13356336429a",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("35545844-bc85-451f-b1ea-e4ca2c2ee911",
	"00000000-0000-0000-0000-000000000000",
	'ifStatementRemember',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'select any root_blk from instances of ACT_BLK 
   where selected.Block_ID == param.blk_id;
select any stmt from instances of ACT_SMT 
   where selected.Statement_ID == param.stmt_id;
stmt.LineNumber = root_blk.CurrentLine;
stmt.StartPosition = root_blk.CurrentCol;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d3ea308a-f69c-4cdb-968b-d38eb48b7d82",
	"35545844-bc85-451f-b1ea-e4ca2c2ee911",
	'blk_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("cfd40498-86ef-411e-b243-d88d797409ed",
	"35545844-bc85-451f-b1ea-e4ca2c2ee911",
	'stmt_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"d3ea308a-f69c-4cdb-968b-d38eb48b7d82",
	'');
INSERT INTO PE_PE
	VALUES ("35545844-bc85-451f-b1ea-e4ca2c2ee911",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a4b5c2e6-efb9-4e45-bad7-b5b7cbc92823",
	"00000000-0000-0000-0000-000000000000",
	'field_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::field_create()
select any attr from instances of O_ATTR where
                                selected.Attr_ID == param.new_attr_or_member_id;
select any member from instances of S_MBR where
                              selected.Member_ID == param.new_attr_or_member_id;
select any newVal from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
select many newVals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
// we want the one with no subtype . . . .
valueFound = false;
for each candidateVal in newVals
  if (not candidateVal.hasSubtype())
    // Leave newVal referring to the instance that had no subtypes
    newVal = candidateVal;
    valueFound = true;
    break;
  end if;
end for;
if (valueFound == false)
  create object instance newVal of V_VAL;
end if;
if (not_empty attr)
  // There should be an Instance Reference Instance previously created.
  // Find it via the original variable found using the passed inst_id.
  select any var from instances of V_VAR where selected.Var_ID ==
                                               param.prev_var_attr_or_member_id;
  if (empty var)
    // TODO report internal error
  else
    select any prevVal related by var->V_IRF[R808]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    if (empty prevVal)
      // TODO report internal error
    else
      create object instance attrRef of V_AVL;
      relate attrRef to newVal across R801;
      relate attrRef to attr across R806;
      select one newDt related by attr->S_DT[R114];
      relate newVal to newDt across R820;
      relate attrRef to prevVal across R807;
    end if;
  end if;
elif (not_empty member)
  // There should be either a Variable, Attribute Reference or a Member
  // Reference previously created. Find it via the original Attribute of
  // Member reference passed in the inst id.
  select any var from instances of V_VAR where selected.Var_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevAttr from instances of O_ATTR where selected.Attr_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevMember from instances of S_MBR where selected.Member_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevParmVal from instances of V_PVL where selected.Value_ID ==
                                               param.prev_var_attr_or_member_id;
  select any prevEvtVal from instances of V_EDV where selected.Value_ID ==
                                               param.prev_var_attr_or_member_id;
  if (empty prevAttr and empty prevMember and
                           empty var and empty prevParmVal and empty prevEvtVal)
    // TODO report internal error
  else
    select any prevVal related by prevAttr->V_AVL[R806]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    if (not_empty prevMember)
      select any prevVal related by prevMember->V_MVL[R836]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    elif (not_empty var)
      select any prevVal related by var->V_TVL[R805]->V_VAL[R801] where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
    elif (not_empty prevParmVal)
      select one prevVal related by prevParmVal->V_VAL[R801];
    else // not_empty prevEvtVal
      select one prevVal related by prevEvtVal->V_VAL[R801];
    end if;
    create object instance memberRef of V_MVL;
    relate memberRef to newVal across R801;
    relate memberRef to member across R836;
    relate memberRef to prevVal across R837;
    select one dt related by member->S_DT[R45];
    relate newVal to dt across R820;
  end if;
end if;
newVal.LineNumber = ::getLineNumber(rule_token:param.token);
newVal.StartPosition = ::getColumn(rule_token:param.token);
newVal.setEndPosition();
return newVal.Value_ID;',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6b92ba7f-d708-423b-bea2-56018d0bd837",
	"a4b5c2e6-efb9-4e45-bad7-b5b7cbc92823",
	'new_attr_or_member_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("1693ef1b-2a88-4fd7-8fdb-29b90f3af712",
	"a4b5c2e6-efb9-4e45-bad7-b5b7cbc92823",
	'prev_var_attr_or_member_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"6b92ba7f-d708-423b-bea2-56018d0bd837",
	'');
INSERT INTO S_SPARM
	VALUES ("8e5b6554-0eaa-4f2b-9e7d-eb8de6c4c6a7",
	"a4b5c2e6-efb9-4e45-bad7-b5b7cbc92823",
	'token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"1693ef1b-2a88-4fd7-8fdb-29b90f3af712",
	'');
INSERT INTO PE_PE
	VALUES ("a4b5c2e6-efb9-4e45-bad7-b5b7cbc92823",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2c30d534-04bb-4611-8d2c-b8dea7b8d729",
	"00000000-0000-0000-0000-000000000000",
	'handle_selected',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'select any val_inst from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
if ( empty val_inst )
  ERR::reportParseError(msg:"R-value not found", token: param.token );
else
  select one attr_val related by val_inst->V_AVL[R807];
  if ( not_empty attr_val )
    select one instRef related by val_inst->V_IRF[R801];
    select one var related by instRef->V_VAR[R808];
    if (not_empty var)
      if (::selected_validate(name:var.Name, rule_token:param.token))
        // migrate to Selected Reference
        select one attr_inst related by attr_val->O_ATTR[R806];
        current_scope = ::get_current_scope();
        select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
        if ( not_empty blk )
          blk.SelectedFound = true;
        end if;
        select one attrRefVal related by attr_val->V_VAL[R801];
        unrelate attr_val from attrRefVal across R801;
        create object instance slr of V_SLR;
        relate slr to attrRefVal across R801;
        relate slr to attr_inst across R812;
        attr_val.dispose();
        // Now that we migrated to a selected reference, we no longer
        // need the instance reference at the start of the chain . . . 
        val_inst.dispose();
      end if;
    end if;
  end if;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("07f6ed6b-bc74-462a-9997-a7221441c4e7",
	"2c30d534-04bb-4611-8d2c-b8dea7b8d729",
	'token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("749f60c7-9603-4601-b759-a72c48c68209",
	"2c30d534-04bb-4611-8d2c-b8dea7b8d729",
	'value_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"07f6ed6b-bc74-462a-9997-a7221441c4e7",
	'');
INSERT INTO PE_PE
	VALUES ("2c30d534-04bb-4611-8d2c-b8dea7b8d729",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d2a50a6-e749-4084-bf52-64204c154fac",
	"00000000-0000-0000-0000-000000000000",
	'param_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::param_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];
select any val from instances of V_VAL where
                                         selected.Value_ID == param.b1_value_id;

select one state_action related by act->ACT_SAB[R698]->SM_ACT[R691];
// If in a state action context or a transition action context, validation was
// done previously in event_root_valude_validate, so here only return Val_ID
if not_empty state_action
  return val.Value_ID;
else
  select one trans_action related by act->ACT_TAB[R698]->SM_ACT[R688];
  if not_empty trans_action
    return val.Value_ID;
  else
    select one sync related by act->ACT_FNB[R698]->S_SYNC[R695];
    if not_empty sync
      select any parm related by sync->S_SPARM[R24] where
                                                 selected.Name == param.a3_text;
      if empty parm
        ::clear_value_data();
        ERR::reportParseError( msg: "Parameter ->%s<- is not associated with function ->"+
       sync.Name+"<-",   token: param.a1_rule_token );
      else
        select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
        if not_empty pvl
          // pvl is empty when the parameter access is happening on a value chain
          // so we get here only when a basic param.param_name access is being used.
          relate pvl to parm across R832;
          select one pdt related by parm->S_DT[R26];
          relate val to pdt across R820;
          val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
          val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
          val.setEndPosition();
        end if;
        return val.Value_ID;
      end if;
    else
      select one tfr related by act->ACT_OPB[R698]->O_TFR[R696];
      if not_empty tfr
        select any parm related by tfr->O_TPARM[R117] where
                                                 selected.Name == param.a3_text;
        if empty parm
          ::clear_value_data();
          ERR::reportParseError( msg: "Parameter ->%s<- is not associated with operation ->"+
                                  tfr.Name+"<-",   token: param.a1_rule_token );
        else
          select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
          if not_empty pvl
            // pvl is empty when the parameter access is happening on a value
            // chain so we get here only when a basic param.param_name access
            // is being used.
            relate pvl to parm across R833;
            select one pdt related by parm->S_DT[R118];
            relate val to pdt across R820;
            val.LineNumber = ::getLineNumber(rule_token: param.a1_rule_token);
            val.StartPosition = ::getColumn(rule_token: param.a1_rule_token);
            val.setEndPosition();
          end if;
          return val.Value_ID;
        end if;
      else
        select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
        if not_empty brg
          select any parm related by brg->S_BPARM[R21] where
                                                 selected.Name == param.a3_text;
          if empty parm
            ::clear_value_data();
            ERR::reportParseError( msg: "Parameter ->%s<- is not associated with bridge ->"+
                                  brg.Name+"<-",   token: param.a1_rule_token );
          else
            select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
            if not_empty val
              if not_empty pvl
                // pvl is empty when the parameter access is happening on a
                // value chain so we get here only when a basic param.param_name
                // access is being used.
                relate pvl to parm across R831;
                select one pdt related by parm->S_DT[R22];
                relate val to pdt across R820;
                val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                val.setEndPosition();
              end if;
              return val.Value_ID;
            end if;
          end if;
        else
          select one reqSig related by act->ACT_RSB[R698]->SPR_RS[R684];
          if not_empty reqSig
            select any parm related by reqSig->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text;
            if empty parm
              ::clear_value_data();
              ERR::reportParseError( msg:
                     "Parameter ->%s<- is not associated with signal ->" +
                             reqSig.Name + "<-",   token: param.a1_rule_token );
            else
              select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
              if not_empty val
                if not_empty pvl
                  // pvl is empty when the parameter access is happening
                  // on a value chain so we get here only when a basic
                  // param.param_name access is being used.
                  relate pvl to parm across R843;
                  select one pdt related by parm->S_DT[R4007];
                  relate val to pdt across R820;
                  val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                  val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                  val.setEndPosition();
                end if;
                return val.Value_ID;
              end if;
            end if;
          else
            select one reqOp related by act->ACT_ROB[R698]->SPR_RO[R685];
            if not_empty reqOp
              select any parm related by reqOp->SPR_REP[R4502]->
                  C_EP[R4500]->C_PP[R4006] where selected.Name == param.a3_text;
              if empty parm
                ::clear_value_data();
                ERR::reportParseError( msg:
              "Parameter ->%s<- is not associated with interface operation ->" +
                              reqOp.Name + "<-",   token: param.a1_rule_token );
              else
                select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                if not_empty val
                  if not_empty pvl
                    // pvl is empty when the parameter access is happening
                    // on a value chain so we get here only when a basic
                    // param.param_name access is being used.
                    relate pvl to parm across R843;
                    select one pdt related by parm->S_DT[R4007];
                    relate val to pdt across R820;
                    val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                    val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                    val.setEndPosition();
                  end if;
                  return val.Value_ID;
                end if;
              end if;
            else
              select one provSig related by act->ACT_PSB[R698]->SPR_PS[R686];
              if not_empty provSig
                select any parm related by provSig->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text;
                if empty parm
                  ::clear_value_data();
                  ERR::reportParseError( msg:
                     "Parameter ->%s<- is not associated with signal ->" +
                            provSig.Name + "<-",   token: param.a1_rule_token );
                else
                  select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                  if not_empty val
                    if not_empty pvl
                      // pvl is empty when the parameter access is happening
                      // on a value chain so we get here only when a basic
                      // param.param_name access is being used.
                      relate pvl to parm across R843;
                      select one pdt related by parm->S_DT[R4007];
                      relate val to pdt across R820;
                      val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                      val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                      val.setEndPosition();
                    end if;
                    return val.Value_ID;
                  end if;
                end if;
              else
                select one provOp related by act->ACT_POB[R698]->SPR_PO[R687];
                if not_empty provOp
                  select any parm related by provOp->SPR_PEP[R4503]->
                  C_EP[R4501]->C_PP[R4006] where selected.Name == param.a3_text;
                  if empty parm
                    ::clear_value_data();
                    ERR::reportParseError( msg:
              "Parameter ->%s<- is not associated with interface operation ->" +
                             provOp.Name + "<-",   token: param.a1_rule_token );
                  else
                    select any pvl from instances of V_PVL where
                                         selected.Value_ID == param.b1_value_id;
                    if not_empty val
                      if not_empty pvl
                        // pvl is empty when the parameter access is happening
                        // on a value chain so we get here only when a basic
                        // param.param_name access is being used.
                        relate pvl to parm across R843;
                        select one pdt related by parm->S_DT[R4007];
                        relate val to pdt across R820;
                        val.LineNumber = ::getLineNumber(rule_token:
                                                           param.a1_rule_token);
                        val.StartPosition = ::getColumn(rule_token:
                                                           param.a1_rule_token);
                        val.setEndPosition();
                      end if;
                      return val.Value_ID;
                    end if;
                  end if;
                end if;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
end if;
return GD::NULL_UNIQUE_ID();',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("13b6eede-8cc7-4048-a55a-dc15a6de7b62",
	"5d2a50a6-e749-4084-bf52-64204c154fac",
	'a1_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("88e838a9-acd7-4de7-a243-ec52e30bd749",
	"5d2a50a6-e749-4084-bf52-64204c154fac",
	'a3_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"13b6eede-8cc7-4048-a55a-dc15a6de7b62",
	'');
INSERT INTO S_SPARM
	VALUES ("320c661d-dd24-4ab7-b31c-06b8f41a1464",
	"5d2a50a6-e749-4084-bf52-64204c154fac",
	'b1_value_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"88e838a9-acd7-4de7-a243-ec52e30bd749",
	'');
INSERT INTO PE_PE
	VALUES ("5d2a50a6-e749-4084-bf52-64204c154fac",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7cab15cb-cdbc-41b1-a125-98ee439edfa7",
	"00000000-0000-0000-0000-000000000000",
	'assignment_create',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// ::assignment_create()
create object instance ata of ACT_AI;
select any value from instances of V_VAL where
                                           selected.Value_ID == param.member_id;
relate ata to value across R689;
select any stmt from instances of ACT_SMT where
                                    selected.Statement_ID == param.statement_id;
if ( empty stmt )
  ERR::reportParseError( msg:  "Statement not found", token: param.token );
  return GD::NULL_UNIQUE_ID();
else
  relate ata to stmt across R603;
  // store the textual position of the attribute name
  ata.attributeLineNumber = ::getLineNumber(rule_token: param.token);
  ata.attributeColumn = ::getColumn(rule_token:param.token);
  return ata.Statement_ID;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9ec7a27c-8af0-44a8-a5d2-92a99d7a62b9",
	"7cab15cb-cdbc-41b1-a125-98ee439edfa7",
	'member_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c4943759-c610-46df-bb49-9362e8590e15",
	"7cab15cb-cdbc-41b1-a125-98ee439edfa7",
	'statement_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"9ec7a27c-8af0-44a8-a5d2-92a99d7a62b9",
	'');
INSERT INTO S_SPARM
	VALUES ("aac7b0fd-eafe-4f5d-8a63-c83cfea967c2",
	"7cab15cb-cdbc-41b1-a125-98ee439edfa7",
	'token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"c4943759-c610-46df-bb49-9362e8590e15",
	'');
INSERT INTO PE_PE
	VALUES ("7cab15cb-cdbc-41b1-a125-98ee439edfa7",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a3b17243-db1e-4c8d-9ae7-ace065295eb5",
	"00000000-0000-0000-0000-000000000000",
	'clear_value_data',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::clear_value_data()
select many vals from instances of V_VAL where
                                      selected.Block_ID == GD::NULL_UNIQUE_ID();
for each val in vals
  val.dispose();
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("a3b17243-db1e-4c8d-9ae7-ace065295eb5",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5f26a60b-34e4-4a7d-b12d-4684d4ef3ffc",
	"00000000-0000-0000-0000-000000000000",
	'getText',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'if ( p_Rule_token != null )
  return p_Rule_token.getText();
else
  return "";
',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("a57b83f4-1e43-4df6-84a4-283badc8bd78",
	"5f26a60b-34e4-4a7d-b12d-4684d4ef3ffc",
	'rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("5f26a60b-34e4-4a7d-b12d-4684d4ef3ffc",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("36d50ffa-8991-4f1c-b4a0-ce27222398eb",
	"00000000-0000-0000-0000-000000000000",
	'get_value_chain_end',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::get_value_chain_end()
select any val from instances of V_VAL where
                                      selected.Value_ID == param.start_value_ID;
atEnd = false;
while not atEnd
  select one attrVal related by val->V_AVL[R807];
  select one membrVal related by val->V_MVL[R837];
  select one arrayVal related by val->V_AER[R838];
  select one arrayLenVal related by val->V_ALV[R840];
  if (not_empty attrVal)
    select one val related by attrVal->V_VAL[R801];
  elif (not_empty membrVal)
    select one val related by membrVal->V_VAL[R801];
  elif (not_empty arrayLenVal)
    select one val related by arrayLenVal->V_VAL[R801];
  elif (not_empty arrayVal)
    select one dt related by val->S_DT[R820];
    select one val related by arrayVal->V_VAL[R801];
    relate val to dt across R820;
  else
   atEnd = true;
  end if;
end while; // Iteration complete
if not_empty val
  return val.Value_ID;
else
  return GD::NULL_UNIQUE_ID();
end if;
',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ddceb893-3325-4e42-85a9-ee56853a9fc6",
	"36d50ffa-8991-4f1c-b4a0-ce27222398eb",
	'start_value_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("36d50ffa-8991-4f1c-b4a0-ce27222398eb",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("463ed1a8-633e-4e34-bb37-aba36348fe4e",
	"00000000-0000-0000-0000-000000000000",
	'get_array_value_root',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::get_array_value_root()
select any val from instances of V_VAL where
                                      selected.Value_ID == param.start_value_ID;
select one arrayRef related by val->V_AER[R801];
while not_empty arrayRef
  select one val related by arrayRef->V_VAL[R838];
  select one arrayRef related by val->V_AER[R801];
end while;
return val.Value_ID;
',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8eae10f5-4376-463b-a831-20b3387fb1bb",
	"463ed1a8-633e-4e34-bb37-aba36348fe4e",
	'start_value_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("463ed1a8-633e-4e34-bb37-aba36348fe4e",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	"00000000-0000-0000-0000-000000000000",
	'param_root_value_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::param_root_value_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];
select any val from instances of V_VAL where
                                         selected.Value_ID == param.a3_value_id;
select one sync related by act->ACT_FNB[R698]->S_SYNC[R695];
if not_empty sync
  select any parm related by sync->S_SPARM[R24] where 
                                                 selected.Name == param.a1_name;
  select one irdt related by parm->S_DT[R26]->S_IRDT[R17];
  if empty parm
    ::clear_value_data();
    ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg:
                     "Parameter ->%s<- is not associated with function ->" +
                                 sync.Name + "<-", token: param.a2_token );
  elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
    ::clear_value_data();
    ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg: "Parameter ->%s<- is not passed by reference" +
                         " and is not assignable", token: param.a2_token );
  else
    select one dt related by parm->S_DT[R26];
    relate val to dt across R820;
    select one parmVal related by val->V_PVL[R801];
    relate parm to parmVal across R832;
    val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
    val.StartPosition = ::getColumn(rule_token: param.a2_token);
    val.setEndPosition();
  end if;
else
  select one tfr related by act->ACT_OPB[R698]->O_TFR[R696];
  if not_empty tfr
    select any parm related by tfr->O_TPARM[R117] where
                                                 selected.Name == param.a1_name;
    select one irdt related by parm->S_DT[R118]->S_IRDT[R17];
    if empty parm
      ::clear_value_data();
      ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
      ERR::reportParseError( msg:
                        "Parameter ->%s<- is not associated with operation ->" +
                                  tfr.Name + "<-", token: param.a2_token );
    elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
      ::clear_value_data();
      ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
      ERR::reportParseError(msg: "Parameter ->%s<- is not passed by reference" +
                         " and is not assignable", token: param.a2_token );
    else
      select one dt related by parm->S_DT[R118];
      relate val to dt across R820;
      select one parmVal related by val->V_PVL[R801];
      relate parm to parmVal across R833;
      val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
      val.StartPosition = ::getColumn(rule_token: param.a2_token);
      val.setEndPosition();
    end if;
  else
    select one brg related by act->ACT_BRB[R698]->S_BRG[R697];
    if not_empty brg
      select any parm related by brg->S_BPARM[R21] where
                                                 selected.Name == param.a1_name;
      select one irdt related by parm->S_DT[R22]->S_IRDT[R17];
      if empty parm
        ::clear_value_data();
        ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: 
                        "Parameter ->%s<- is not associated with bridge ->" +
                                  brg.Name + "<-", token: param.a2_token );
      elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
        ::clear_value_data();
        ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
               " reference and is not assignable", token: param.a2_token );
      else
        select one dt related by parm->S_DT[R22];
        relate val to dt across R820;
        select one parmVal related by val->V_PVL[R801];
        relate parm to parmVal across R831;
        val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
        val.StartPosition = ::getColumn(rule_token: param.a2_token);
        val.setEndPosition();
      end if;
    else
      select one requiredSignal related by act->ACT_RSB[R698]->SPR_RS[R684];
      select one requiredOperation related by act->ACT_ROB[R698]->SPR_RO[R685];
      select one providedSignal related by act->ACT_PSB[R698]->SPR_PS[R686];
      select one providedOperation related by act->ACT_POB[R698]->SPR_PO[R687];
      if(not_empty requiredSignal)
        select any parm related by requiredSignal->SPR_REP[R4502]->C_EP[R4500]
                             ->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
               "Parameter ->%s<- is not associated with required signal ->" +
                            requiredSignal.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty requiredOperation)
        select any parm related by requiredOperation->SPR_REP[R4502]
                ->C_EP[R4500]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
            "Parameter ->%s<- is not associated with required operation ->" +
                            requiredOperation.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty providedSignal)
        select any parm related by providedSignal->SPR_PEP[R4503]
                ->C_EP[R4501]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
               "Parameter ->%s<- is not associated with provided signal ->" +
                            providedSignal.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      elif(not_empty providedOperation)
        select any parm related by providedOperation->SPR_PEP[R4503]
                ->C_EP[R4501]->C_PP[R4006] where selected.Name == param.a1_name;
        select one irdt related by parm->S_DT[R4007]->S_IRDT[R17];
        if empty parm
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: 
            "Parameter ->%s<- is not associated with provided operation ->" +
                            providedOperation.Name + "<-", token: param.a2_token );
        elif val.isLValue and parm.By_Ref == 0 and
                                       ((empty irdt) or (param.a4_isRootAccess))
          ::clear_value_data();
          ::set_token(a1_token:param.a2_token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
          ERR::reportParseError(msg: "Parameter ->%s<- is not passed by" +
                    " reference and is not assignable", token: param.a2_token );
        else
          select one dt related by parm->S_DT[R4007];
          relate val to dt across R820;
          select one parmVal related by val->V_PVL[R801];
          relate parm to parmVal across R843;
          val.LineNumber = ::getLineNumber(rule_token: param.a2_token);
          val.StartPosition = ::getColumn(rule_token: param.a2_token);
          val.setEndPosition();
        end if;
      end if;
    end if;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("08e21e3b-754f-449a-bf3f-04c0c2f23fec",
	"1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	'a1_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("ef589eed-b359-431a-b822-e1b64fed1f8e",
	"1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	'a2_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"08e21e3b-754f-449a-bf3f-04c0c2f23fec",
	'');
INSERT INTO S_SPARM
	VALUES ("1ad9f938-bef7-4e81-9d8e-5ba488ed048e",
	"1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	'a3_value_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"ef589eed-b359-431a-b822-e1b64fed1f8e",
	'');
INSERT INTO S_SPARM
	VALUES ("4f55403d-9898-475f-810b-56679f54727e",
	"1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	'a4_isRootAccess',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"1ad9f938-bef7-4e81-9d8e-5ba488ed048e",
	'');
INSERT INTO PE_PE
	VALUES ("1e6e8583-8c03-4ce6-8a2f-d25e115dd9a5",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fa1f44b1-5e9e-46ea-9937-ecc0da11ccff",
	"00000000-0000-0000-0000-000000000000",
	'event_root_value_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::event_root_value_validate()
current_scope = ::get_current_scope();
select any blk from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one act related by blk->ACT_ACT[R612];

select one sm_act related by act->ACT_SAB[R698]->SM_ACT[R691];
if empty sm_act
  select one sm_act related by act->ACT_TAB[R698]->SM_ACT[R688];
end if;
if empty sm_act
  ERR::reportParseError(msg: "The ->rcvd_evt<- keyword cannot be used in a " +
               "non-state action. Use ->param<- instead.", token: param.token );
end if;
select one sm_sab related by act->ACT_SAB[R698];
if not_empty sm_sab
  // check state action 
  select many txns related by 
               sm_act->SM_AH[R514]->SM_MOAH[R513]->SM_STATE[R511]->SM_TXN[R506];
  if cardinality txns > 0
    for each txn in txns
      select one nsTxn related by txn->SM_NSTXN[R507];
      select one trigger related by nsTxn->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
      if empty nsTxn
        select one crTxn related by txn->SM_CRTXN[R507];
        if not_empty crTxn
          select one trigger related by crTxn->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
        else
          ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when one or more" +
                         " incoming transitions do not have events assigned.",
                                                           token: param.token );
          break;
        end if;
      end if; // empty new state transition
      select one nlevt related by trigger->SM_SEVT[R525]->SM_NLEVT[R526];
      select one pevt related by nlevt->SM_PEVT[R527];
      if not_empty pevt
        select one trigger related by pevt->SM_EVT[R525];
      end if;
      select any val from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
      if val.isLValue
        ::clear_value_data();
        ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
        ERR::reportParseError(msg: "Event parameters" +
                                    " are not assignable", token: param.token );
        break;
      else
        select one sigEvt related by trigger->SM_SEVT[R525]->SM_SGEVT[R526];
        if empty sigEvt // its a regular event with parameters
          select any edi related by trigger->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
          if not_empty edi
            select one edv related by val->V_EDV[R801];
            if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
            end if;
            create object instance epr of V_EPR;
            relate epr to edv across R834; 
            relate epr to edi across R846;
            select one edt related by edi->S_DT[R524];
            relate val to edt across R820;
            val.setEndPosition();
            select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
            if (not_empty arrayElemRef)
			  leafElem = arrayElemRef;
      		  while (not_empty arrayElemRef)
      		    leafElem = arrayElemRef;
      		    select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      		  end while;
              if leafElem.getDimensions() < 0
                 ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			     ERR::reportParseError( 
                             msg: "Parameter ->%s<- has incompatible array depth." ,
                                                         token: param.token );
              end if;
            end if;
            //
          end if; // if no event parameter found, error will be reported below
        else // a signal reference . . . 
          select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
          if empty exProp
            select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
          end if;
          if not_empty exProp
            select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
            if not_empty sigParm
              select one edv related by val->V_EDV[R801];
              if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
              end if;
              create object instance epr of V_EPR;
              relate epr to edv across R834; 
              relate epr to sigParm across R847;
              select one pdt related by sigParm->S_DT[R4007];
              relate val to pdt across R820;
              val.setEndPosition();
              select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
              if (not_empty arrayElemRef)
       		    leafElem = arrayElemRef;
      		    while (not_empty arrayElemRef)
      		      leafElem = arrayElemRef;
      		      select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      		    end while;
                if leafElem.getDimensions() < 0
                   ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			       ERR::reportParseError( 
                               msg: "Parameter ->%s<- has incompatible array depth." ,
                                                           token: param.token );
                end if;
              end if;
            end if; // if no signal parameter found, error is reported below 
          else
            USER::logError(msg:"event_root_value_validate:" +
               " No signal declaration found for signal event carrying "
                                                                  + param.name,path:"PathNotProvided");
          end if;
        end if;  // empty signal event
      end if; // not l-value
    end for;
  else // no transitions found
    ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when there" +
                          " are no incoming transitions.", token: param.token );
  end if;
  // Now check that events on all incoming transitions carry the referenced
  // parameter. We do this in a separate loop because we don''''t want to consider
  // the same event more than once, as is likely when iterating transitions . .
  badEventList = "";
  sep = "";
  select many ns_triggers related by txns->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  select any ns_evt related by txns->SM_NSTXN[R507]->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  for each ns_evt in ns_triggers
    select one nlevt related by ns_evt->SM_SEVT[R525]->SM_NLEVT[R526];
    if not_empty nlevt
      select one pevt related by nlevt->SM_PEVT[R527];
      if empty pevt
        ERR::reportParseError( 
           msg:"Parameter ->%s<- belongs to a Polymorphic Event that is no " +
                            "longer defined in supertype", token: param.token );
        break;
      else
        select one ns_evt related by pevt->SM_EVT[R525];
      end if;
    end if;
    select one sigEvt related by ns_evt->SM_SEVT[R525]->SM_SGEVT[R526];
    if not_empty sigEvt
      select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
      if empty exProp
        select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
      end if;
      if not_empty exProp
        select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
        if empty sigParm
          badEventList = badEventList + sep + ns_evt.Mning;
          sep = ", ";
        end if;
      end if;
    else
      select any edi related by ns_evt->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
      if empty edi
        badEventList = badEventList + sep + ns_evt.Mning;
        sep = ", ";
      end if;
    end if;
  end for;
  // Need to repeat the same check for creation transitions
  select many triggers related by txns->SM_CRTXN[R507]->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
  select any cr_evt related by txns->SM_CRTXN[R507]->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
  for each cr_evt in triggers
    alreadyReported = false;
    for each prevCheckedEvt in ns_triggers
      if cr_evt == prevCheckedEvt
        alreadyReported = true;
        break;
      end if;
    end for;
    if not alreadyReported 
      select one pevt related by cr_evt->SM_SEVT[R525]->
                                                  SM_NLEVT[R526]->SM_PEVT[R527];
      if not_empty pevt
        select one cr_evt related by pevt->SM_EVT[R525];
      end if;
      select one sigEvt related by cr_evt->SM_SEVT[R525]->SM_SGEVT[R526];
      if not_empty sigEvt
        select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
        if empty exProp
          select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
        end if;
        if not_empty exProp
          select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
          if empty sigParm
            badEventList = badEventList + sep + cr_evt.Mning;
            sep = ", ";
          end if;
        end if;
      else
        select any edi related by cr_evt->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
        if empty edi
          badEventList = badEventList + sep + cr_evt.Mning;
          sep = ", ";
        end if;
      end if;
    end if;
  end for;
  if badEventList != ""
    ERR::reportParseError( 
              msg: "The following incoming messages do not carry required" +
                                          " parameter ->%s<- " + badEventList,
                                                           token: param.token );
  end if;
else // check transition action
  select one txn related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530];
  select one nsTxn related by txn->SM_NSTXN[R507];
  select one trigger related by nsTxn->SM_SEME[R504]->
                                                    SM_SEVT[R503]->SM_EVT[R525];
  if empty nsTxn
    select one crTxn related by txn->SM_CRTXN[R507];
    if not_empty crTxn
      select one trigger related by crTxn->SM_LEVT[R509]->
                                                    SM_SEVT[R526]->SM_EVT[R525];
    else
      ERR::reportParseError( 
              msg: "Attempted to access parameter ->%s<- when associated" +
                               " transition does not have an event assigned.",
                                                           token: param.token );
    end if;
  end if; // empty new state transition
  select one nlevt related by trigger->SM_SEVT[R525]->SM_NLEVT[R526];
  if not_empty nlevt
    select one pevt related by nlevt->SM_PEVT[R527];
    if empty pevt
      ERR::reportParseError(
           msg:"Parameter ->%s<- belongs to a Polymorphic Event that is no " +
                            "longer defined in supertype", token: param.token );
    else
      select one trigger related by pevt->SM_EVT[R525];
    end if;
  end if;
  select any val from instances of V_VAL where
                                            selected.Value_ID == param.value_id;
  if val.isLValue
    ::clear_value_data();
    ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
    ERR::reportParseError(msg: "Event parameters" +
                                    " are not assignable", token: param.token );
  else
    select one sigEvt related by trigger->SM_SEVT[R525]->SM_SGEVT[R526];
    if empty sigEvt // its a regular event with parameters
      select any edi related by trigger->SM_EVTDI[R532] where
                                                    selected.Name == param.name;
      if not_empty edi
        select one edv related by val->V_EDV[R801];
        if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
        end if;
        create object instance epr of V_EPR;
        relate epr to edv across R834; 
        relate epr to edi across R846;
        select one edt related by edi->S_DT[R524];
        relate val to edt across R820;
        val.setEndPosition();
        select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
        if (not_empty arrayElemRef)
       	  leafElem = arrayElemRef;
      	  while (not_empty arrayElemRef)
      	    leafElem = arrayElemRef;
      		select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      	  end while;
          if leafElem.getDimensions() < 0
            ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);    
			ERR::reportParseError( 
                    msg: "Parameter ->%s<- has incompatible array depth." ,
                                                 token: param.token );
          end if;
        end if;
      else
        ERR::reportParseError( 
           msg:"Parameter ->%s<- is not carried by event " + trigger.Mning,
                                                           token: param.token );
      end if;
    else  // a signal reference
      select one exProp related by sigEvt->SPR_PS[R528]->
                                                    SPR_PEP[R4503]->C_EP[R4501];
      if empty exProp
        select one exProp related by sigEvt->SPR_RS[R529]->
                                                    SPR_REP[R4502]->C_EP[R4500];
      end if;
      if not_empty exProp
        select any sigParm related by exProp->C_PP[R4006] where
                                                    selected.Name == param.name;
        if not_empty sigParm
          select one edv related by val->V_EDV[R801];
          if empty edv
              USER::logError(msg:"event_root_value_validate:" +
                   " Value is not an event value " + param.name,path:"PathNotProvided");
          end if;
          create object instance epr of V_EPR;
          relate epr to edv across R834; 
          relate epr to sigParm across R847;
          select one pdt related by sigParm->S_DT[R4007];
          relate val to pdt across R820;
          val.setEndPosition();
          select one arrayElemRef related by val->V_AER[R838]->V_VAL[R801];
          if (not_empty arrayElemRef)
            leafElem = arrayElemRef;
       	    while (not_empty arrayElemRef)
      	      leafElem = arrayElemRef;
      		  select one arrayElemRef related by arrayElemRef->V_AER[R838]->V_VAL[R801];
      	    end while;
            if leafElem.getDimensions() < 0
              ::set_token(a1_token:param.token, a2_line:val.LineNumber,
                                 a3_column:val.StartPosition, a4_text:val.Text);
			  ERR::reportParseError( 
                      msg: "Parameter ->%s<- has incompatible array depth." ,
                                                   token: param.token );
            end if;
          end if;
        else
          ERR::reportParseError( 
            msg:"Parameter ->%s<- is not carried by signal " +
                                            trigger.Mning, token: param.token );
        end if; // if no signal parameter found, error will be reported below 
      else
        USER::logError(msg:"event_root_value_validate:" +
             " No signal declaration found for signal event carrying "
                                                                  + param.name,path:"PathNotProvided");
      end if;
    end if;
  end if; // not l-value
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bf744b36-6204-44b3-925e-2259f869007d",
	"fa1f44b1-5e9e-46ea-9937-ecc0da11ccff",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("66aab20c-c3b4-47eb-bd5d-624e0255cf87",
	"fa1f44b1-5e9e-46ea-9937-ecc0da11ccff",
	'token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"bf744b36-6204-44b3-925e-2259f869007d",
	'');
INSERT INTO S_SPARM
	VALUES ("bfaa22a9-446c-46ad-b674-0f91ea2c33c5",
	"fa1f44b1-5e9e-46ea-9937-ecc0da11ccff",
	'value_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"66aab20c-c3b4-47eb-bd5d-624e0255cf87",
	'');
INSERT INTO PE_PE
	VALUES ("fa1f44b1-5e9e-46ea-9937-ecc0da11ccff",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	"00000000-0000-0000-0000-000000000000",
	'array_length_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
',
	'// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
// ::array_length_validate
result = false;
if (param.a1_name == "length" or param.a1_name == "Length") and param.a2_isArray
  select any curVal from instances of V_VAL where
                                        selected.Value_ID == param.a3_curVal_ID;
  if (curVal.isLValue)
    ::clear_value_data();
    ERR::reportParseError( msg: "Array length is read only. OAL arrays do " +
                              "not need to be sized. ", token: param.a4_token );
  else
    // Successfully recognized an array length reference
    // to an array of simple data types.
    create object instance alVal of V_ALV;
    relate alVal to curVal across R801;

      cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where selected.Name == cur_sys_name;
      dt_id = GD::NULL_UNIQUE_ID();
      if not_empty sys
        dt_id = sys.getCoreTypeId(name:"integer");
      end if;
      select any pe from instances of PE_PE where selected.Element_ID == dt_id;
      select one intDt related by pe->S_DT[R8001]; 

    if ( not_empty intDt )
      relate curVal to intDt across R820;
    else
      USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                        "array_length_validate().  Variable <intDt> is empty.",path:"PathNotProvided");
    end if;
    select any endVal from instances of V_VAL where
                                        selected.Value_ID == param.a5_endVal_ID;
    relate endVal to alVal across R840;
    result = true;
  end if;
end if;
return result;',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("afa95770-9a62-4590-b9c7-a35819fc5957",
	"caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	'a1_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("69e80db3-7530-4100-9385-83b6ccac7c65",
	"caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	'a2_isArray',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"afa95770-9a62-4590-b9c7-a35819fc5957",
	'');
INSERT INTO S_SPARM
	VALUES ("6a2e3894-e182-4a39-811a-c57cb836083c",
	"caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	'a3_curVal_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"69e80db3-7530-4100-9385-83b6ccac7c65",
	'');
INSERT INTO S_SPARM
	VALUES ("71866f91-d193-4acb-98e3-612ff9d2b44f",
	"caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	'a4_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"6a2e3894-e182-4a39-811a-c57cb836083c",
	'');
INSERT INTO S_SPARM
	VALUES ("71818688-9128-43af-8e23-fff33b82964f",
	"caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	'a5_endVal_ID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"71866f91-d193-4acb-98e3-612ff9d2b44f",
	'');
INSERT INTO PE_PE
	VALUES ("caa0aff2-00f3-4d8b-89d7-dbf11d6aa213",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	"00000000-0000-0000-0000-000000000000",
	'set_token',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'    if (p_A1_token != null) {
    	p_A1_token.setLine(p_A2_line);
    	p_A1_token.setColumn(p_A3_column);
    	p_A1_token.setText(p_A4_text);
    }
',
	"ba5eda7a-def5-0000-0000-000000000000",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("1bdd3a9f-758b-4efa-b9f4-22214b978249",
	"83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	'a1_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("bc0894c7-8b92-47dd-ab88-5a3bc531a203",
	"83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	'a2_line',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"1bdd3a9f-758b-4efa-b9f4-22214b978249",
	'');
INSERT INTO S_SPARM
	VALUES ("6e4f3a06-a999-42de-b4be-ab2e9668df4e",
	"83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	'a3_column',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"bc0894c7-8b92-47dd-ab88-5a3bc531a203",
	'');
INSERT INTO S_SPARM
	VALUES ("c645a6ae-f5e0-495d-b0d5-c6fee4e3142d",
	"83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	'a4_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"6e4f3a06-a999-42de-b4be-ab2e9668df4e",
	'');
INSERT INTO PE_PE
	VALUES ("83cb8d47-efbb-4e87-b8bd-1cd5b53be5f8",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("34d57782-6059-4488-bcd0-d9dd71e7b3a5",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_message',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::isValidMessage()
select any requirement from instances of C_R where
                                      selected.Requirement_Id == param.a1_ifRef;
select any provision from instances of C_P where
                                        selected.Provision_Id == param.a1_ifRef;
select one interface related by requirement->C_IR[R4009]->C_I[R4012];
if empty interface
  select one interface related by provision->C_IR[R4009]->C_I[R4012];
end if;
select any signal related by interface->C_EP[R4003]->C_AS[R4004] where
                                              selected.Name == param.a2_msgName;
select any op related by interface->C_EP[R4003]->C_IO[R4004] where
                                              selected.Name == param.a2_msgName;
select one message related by signal->C_EP[R4004];
if empty message
  select one message related by op->C_EP[R4004];
end if;
if empty message
  ERR::reportParseError(
       msg: "Cannot find specified message ->%s<-", token: param.a3_rule_token);
else
  // create a value, if there is no return value it will be removed later
  create object instance msv of V_MSV;
  msv.ParmListOK = true;
  create object instance val of V_VAL;
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                selected.Block_ID == current_scope;
  relate val to block across R826;
  relate val to msv across R801;
  // find the required or provided executable property
  if(not_empty provision)
    select any proEP related by message->SPR_PEP[R4501]
                        where (selected.Provision_Id == provision.Provision_Id);
    if(not_empty proEP)
      relate proEP to msv across R841; 
    end if;
  elif(not_empty requirement)
    select any reqEP related by message->SPR_REP[R4500]
                  where (selected.Requirement_Id == requirement.Requirement_Id);
    if(not_empty reqEP)
      relate reqEP to msv across R845;
    end if;
  end if;
  val.LineNumber = ::getLineNumber(rule_token: param.a3_rule_token);
  val.StartPosition = ::getColumn(rule_token: param.a3_rule_token);
  val.setEndPosition();
  // store the textual position of the interface name
  msv.ownerNameLineNumber = block.currentKeyLettersLineNumber;
  msv.ownerNameColumn = block.currentKeyLettersColumn;
  select one bdt related by op-> S_DT[R4008];
  if empty bdt
    if not_empty signal
      // it can''t return anything

        cur_sys_name = ::getSystemName();
        select any sys from instances of S_SYS where selected.Name == cur_sys_name;
        dt_id = GD::NULL_UNIQUE_ID();
        if not_empty sys
          dt_id = sys.getCoreTypeId(name:"void");
        end if;
        select any pe from instances of PE_PE where selected.Element_ID == dt_id;
        select one bdt related by pe->S_DT[R8001]; 

      if empty bdt
        USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
                               "is_valid_message().  Variable <bdt> is empty.",path:"PathNotProvided");
      end if;
    else
      USER::logError(msg:"is_valid_message: internal error" +
                               " no return type found for interface operation",path:"PathNotProvided");
    end if;
  end if;
  relate val to bdt across R820;
  return val.Value_ID;
end if;
return GD::NULL_UNIQUE_ID();',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0a7956b4-4fa8-4740-9b46-337377c8dd4b",
	"34d57782-6059-4488-bcd0-d9dd71e7b3a5",
	'a1_ifRef',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a6473745-da26-48aa-87a2-03d095904fb9",
	"34d57782-6059-4488-bcd0-d9dd71e7b3a5",
	'a2_msgName',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0a7956b4-4fa8-4740-9b46-337377c8dd4b",
	'');
INSERT INTO S_SPARM
	VALUES ("0dbce9f0-4f5c-4976-ab3a-9e46d27796a2",
	"34d57782-6059-4488-bcd0-d9dd71e7b3a5",
	'a3_rule_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"a6473745-da26-48aa-87a2-03d095904fb9",
	'');
INSERT INTO PE_PE
	VALUES ("34d57782-6059-4488-bcd0-d9dd71e7b3a5",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0e37c709-ee9f-4fde-99d2-0316e4d6e64f",
	"00000000-0000-0000-0000-000000000000",
	'sender_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'if param.a1_name == "Sender" or param.a1_name == "sender" or
                                                       param.a1_name == "SENDER"
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  select one body related by block->ACT_ACT[R612];
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if empty component
    ::clear_value_data();
    ERR::reportParseError(
         msg: "Sender keyword is valid only in the context of a component",
                                                        token: param.a3_token );
  else
    if param.a2_isLval
      ::clear_value_data();
      ERR::reportParseError( msg: "Cannot assign a value to ->%s<-.",
                                                        token: param.a3_token );
    else
      var_id = ::get_var_in_scope( name: param.a1_name,
                                                   rule_token: param.a3_token );
      if ( var_id == GD::NULL_UNIQUE_ID() )
        errMsg = ::is_valid_implicit_component_addressing();
        if errMsg == ""
          select one outer_blk related by body->ACT_BLK[R650];
          create object instance sndr of V_TRN;
          create object instance var_inst of V_VAR;
          relate var_inst to sndr across R814;
          var_inst.Name = param.a1_name;
          relate var_inst to outer_blk across R823;

            cur_sys_name = ::getSystemName();
            select any sys from instances of S_SYS where
                                                  selected.Name == cur_sys_name;
            dt_id = GD::NULL_UNIQUE_ID();
            if not_empty sys
              dt_id = sys.getCoreTypeId(name:"component_ref");
            end if;
            select any pe from instances of PE_PE where selected.Element_ID == dt_id;
            select one dt related by pe->S_DT[R8001];

          if ( not_empty dt )
            relate var_inst to dt across R848;
          else
            USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
              "sender_validate().  Variable <dt> is empty.",path:"PathNotProvided");
          end if;
          var_inst.Declared = true;
        else
          ::clear_value_data();
          ERR::reportParseError( msg: errMsg, token: param.a3_token );
        end if;
      end if;  // var_id == GD::NULL_UNIQUE_ID
    end if; // not an Lval
  end if; // component in context
end if; // keyword matches
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4e2aa1ad-f237-4d23-bfba-bd6db99cef6a",
	"0e37c709-ee9f-4fde-99d2-0316e4d6e64f",
	'a1_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("97783d4f-96f6-4612-8e0c-d7d10137db0e",
	"0e37c709-ee9f-4fde-99d2-0316e4d6e64f",
	'a2_isLval',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"4e2aa1ad-f237-4d23-bfba-bd6db99cef6a",
	'');
INSERT INTO S_SPARM
	VALUES ("ec0cd027-1584-460e-9ef7-84ad029e5b70",
	"0e37c709-ee9f-4fde-99d2-0316e4d6e64f",
	'a3_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"97783d4f-96f6-4612-8e0c-d7d10137db0e",
	'');
INSERT INTO PE_PE
	VALUES ("0e37c709-ee9f-4fde-99d2-0316e4d6e64f",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("383b5e6b-0a0f-47a1-9b6c-a2701dfa0651",
	"00000000-0000-0000-0000-000000000000",
	'is_valid_implicit_component_addressing',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'// ::is_valid_implicit_component_addressing()
prefAllowImplicitComponentAddressing =
                        "bridgepoint_prefs_allow_implicit_component_addressing";
if PREF::getBoolean( name:prefAllowImplicitComponentAddressing) == false
  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
  select one body related by block->ACT_ACT[R612];
  // implicit addressing may be valid in interface bodies
  select one psb related by body->ACT_PSB[R698];
  select one pob related by body->ACT_POB[R698];
  select one rsb related by body->ACT_RSB[R698];
  select one rob related by body->ACT_ROB[R698];
  if empty psb and empty pob and empty rsb and empty rob
    select one sab related by body->ACT_SAB[R698];
    select one tab related by body->ACT_TAB[R698];
    if not_empty sab
      select one csm related by sab->SM_ACT[R691]->SM_SM[R515]->SM_ASM[R517];
      if not_empty csm
        select one state related by sab->SM_ACT[R691]->SM_AH[R514]->
                                                  SM_MOAH[R513]->SM_STATE[R511];
        // select all incoming transitions
        select many txns related by state->SM_TXN[R506];
        select many sigs related by txns->SM_NSTXN[R507]->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
        if cardinality txns == cardinality sigs
          // all is well
          return "";
        else
           return "Sender keyword can only be used where " +
                       "there are signals assigned to all incoming transitions";
        end if;
      end if; // is a class state model
    elif not_empty tab
      select one csm related by tab->SM_ACT[R688]->SM_SM[R515]->SM_ASM[R517];
      if not_empty csm
        select one txn related by tab->SM_ACT[R688]->SM_AH[R514]->
                                                     SM_TAH[R513]->SM_TXN[R530];
        select one sig related by txn->SM_NSTXN[R507]->
                                   SM_SEME[R504]->SM_SEVT[R503]->SM_SGEVT[R526];
        if not_empty sig
          // all is well
          return "";
        else
          return "Sender keyword can only be used when " +
                                      "a signal is assigned to this transition";
        end if;
      end if; // is a class state model
    end if; // is a state or transition action
    return "Sender keyword is valid " +
                                    "only where a message is serviced directly";
  else // it is a signal or operation, check the direction is incoming
    direction = IFDirectionType::ClientServer;
    targetType = "Signal";
    if not_empty psb or not_empty pob
      select one as related by psb->SPR_PS[R686]->SPR_PEP[R4503]->
                                                       C_EP[R4501]->C_AS[R4004];
      if not_empty as
        direction = as.Direction;
      end if;
      if not_empty pob
        select one op related by pob->SPR_PO[R687]->SPR_PEP[R4503]->
                                                       C_EP[R4501]->C_IO[R4004];
        targetType = "Interface Operation";
        if not_empty op
          direction = op.Direction;
        end if;
        if direction != IFDirectionType::ClientServer
          return "Sender keyword can only be used in an incoming " +
                                                               targetType + ".";
        end if;
      end if;
    else
      select one as related by rsb->SPR_RS[R684]->SPR_REP[R4502]->
                                                       C_EP[R4500]->C_AS[R4004];
      if not empty as
        direction = as.Direction;
      end if;
      if not_empty rob
        select one op related by rob->SPR_RO[R685]->SPR_REP[R4502]->
                                                       C_EP[R4500]->C_IO[R4004];
        targetType = "Interface Operation";
        if not_empty op
          direction = op.Direction;
        end if;
      end if;
      if direction != IFDirectionType::ServerClient
        return "Sender keyword can only be used in an incoming " +
                                                               targetType + ".";
      end if;
    end if;
  end if;
end if;
return "";',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("383b5e6b-0a0f-47a1-9b6c-a2701dfa0651",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("07a55daa-f7e9-4bcb-b566-20dcdea26ed4",
	"00000000-0000-0000-0000-000000000000",
	'getSystemName',
	'This function uses the model root parameter that is passed to the function in
the parser code.

It returns the system/project name using the inherited static function
getProjectNameFromModelRootId().

ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'return Ooaofooa.getProjectNameFromModelRootId(modelRoot.getId());',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'');
INSERT INTO PE_PE
	VALUES ("07a55daa-f7e9-4bcb-b566-20dcdea26ed4",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bff6bbd0-6b99-4423-b5fb-cfa43c282979",
	"00000000-0000-0000-0000-000000000000",
	'getValidationDomain',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
',
	'java.util.UUID result = org.xtuml.bp.core.common.IdAssigner.NULL_UUID;

if (this.m_nrme != null) {
  result = this.m_nrme.Get_ooa_id();
}
return result;
',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'');
INSERT INTO PE_PE
	VALUES ("bff6bbd0-6b99-4423-b5fb-cfa43c282979",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3483c3fb-1b94-4123-b241-2911a2d257b2",
	"00000000-0000-0000-0000-000000000000",
	'connect_inst_ref_var_to_datatype',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE
------------------
This function is used to connect a V_INT or V_INS instance''s V_VAR supertype
to the corresponding inst_ref<[classname]> or inst_ref_set<[classname]>
datatype.

Typically this is done after migrating a V_TRN to one of these instance
reference types.
',
	'// OAL Validation Utility Function::connect_inst_ref_var_to_datatype()

select any obj from instances of O_OBJ where selected.Obj_ID == param.p3_obj_id;
select any irdt related by obj->S_IRDT[R123] where selected.isSet == param.p1_is_set;
select any vvar from instances of V_VAR where selected.Var_ID == param.p2_var_id;

if (not_empty irdt)
  select one dt related by irdt->S_DT[R17];
  relate vvar to dt across R848;
else
  // Didn''t find a match for the class, set the datatype to the inst_ref<Object>
  // or inst_ref_set<Object> generic instance reference.
  dt_name = "inst_ref<Object>";
  if (param.p1_is_set)
    dt_name = "inst_ref_set<Object>";
  end if;

  elemId = ::getValidationDomain();
  select any dt1_dt from instances of S_DT where false;

select any packageableElem from instances of PE_PE where
                                              selected.Element_ID == elemId;
select one package related by packageableElem->EP_PKG[R8000];
select one component related by packageableElem->C_C[R8003];
hasParent = not_empty package or not_empty component;
      if (hasParent)
	      dtID = packageableElem.resolveDataTypeRelativeToSelf(
	                                   expected_name:dt_name, default_name:dt_name);
	      select any dt1_dt related by package->PE_VIS[R8002]->
	                         PE_PE[R8002]->S_DT[R8001] where selected.DT_ID == dtID;
	      if (empty dt1_dt)
	        select any dt1_dt related by component->PE_CVS[R8004]->
	                         PE_PE[R8004]->S_DT[R8001] where selected.DT_ID == dtID;
	      end if;
     end if;
    if (empty dt1_dt)
      dt_id = GD::NULL_UNIQUE_ID();
      cur_sys_name = ::getSystemName();
      select any sys from instances of S_SYS where
                                            (selected.Name == cur_sys_name);
  			  if not_empty sys   
                dt_id = sys.getCoreTypeId(name:dt_name);
		      select any pe related by sys->G_EIS[R9100]->PE_PE[R9100]
		                                                where selected.Element_ID == dt_id;
		      select one dt1_dt related by pe->S_DT[R8001];
		      end if; 
      end if; 

  if not_empty dt1_dt
    relate vvar to dt1_dt across R848;
  else
    USER::logError(msg: "Internal Error in OAL Validation Utility Function " +
        "connect_inst_ref_var_to_datatype().  Variable <dt1_dt> is empty.",path:"PathNotProvided");
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("035e5714-0546-458a-8fb0-fa610b0a2c21",
	"3483c3fb-1b94-4123-b241-2911a2d257b2",
	'p1_is_set',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("dc8e448a-34dc-45ac-8c7a-ca8d8859003a",
	"3483c3fb-1b94-4123-b241-2911a2d257b2",
	'p2_var_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"035e5714-0546-458a-8fb0-fa610b0a2c21",
	'');
INSERT INTO S_SPARM
	VALUES ("aec5add0-dc84-4bce-bd5e-fd48b1ce7795",
	"3483c3fb-1b94-4123-b241-2911a2d257b2",
	'p3_obj_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"dc8e448a-34dc-45ac-8c7a-ca8d8859003a",
	'');
INSERT INTO PE_PE
	VALUES ("3483c3fb-1b94-4123-b241-2911a2d257b2",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a195b610-80c0-4c53-92d6-8ea2cdb892c7",
	"00000000-0000-0000-0000-000000000000",
	'has_substring',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native
-----------
Utility function that wraps Java indexOf() to search for a substring.',
	'return p_P1_base.indexOf(p_P2_str, p_P3_fromindex) != -1;',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("bdd0c7f2-8105-48aa-9bc9-39fffdd5d3ac",
	"a195b610-80c0-4c53-92d6-8ea2cdb892c7",
	'p1_base',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("88836482-3c41-4df2-8310-eaa23cb04a20",
	"a195b610-80c0-4c53-92d6-8ea2cdb892c7",
	'p2_str',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bdd0c7f2-8105-48aa-9bc9-39fffdd5d3ac",
	'');
INSERT INTO S_SPARM
	VALUES ("32f76a68-5e83-4e75-9ed0-684d670bb950",
	"a195b610-80c0-4c53-92d6-8ea2cdb892c7",
	'p3_fromIndex',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"88836482-3c41-4df2-8310-eaa23cb04a20",
	'');
INSERT INTO PE_PE
	VALUES ("a195b610-80c0-4c53-92d6-8ea2cdb892c7",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11b6192c-1ebe-49e9-b164-b9f2291b604e",
	"00000000-0000-0000-0000-000000000000",
	'is_message_direction_valid',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if isInGenericPackage
  select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
  select one component related by containingElem->C_C[R8001];
  if(not_empty component)
    select any ifRef related by component->C_PO[R4010]->C_IR[R4016]
                                      where (selected.Id == param.interface_id);
    if(param.direction == IFDirectionType::ServerClient)
      select one provision related by ifRef->C_P[R4009];
      if(empty provision)
        // the body is on the client side yet the expected
        // direction is server -> client
        return false;
      end if;
    else
      select one requirement related by ifRef->C_R[R4009];
      if(empty requirement)
        // the body is on the server side yet the expected
        // direction is client -> server
        return false;
      end if;
    end if;
  end if;
  return true;
else
  body.associateWithOwningComponent();
  select one component related by body->ACT_BIC[R694]->C_C[R694];
  if(not_empty component)
    select any ifRef related by component->C_PO[R4010]->C_IR[R4016]
                                      where (selected.Id == param.interface_id);
    if(param.direction == IFDirectionType::ServerClient)
      select one provision related by ifRef->C_P[R4009];
      if(empty provision)
        // the body is on the client side yet the expected
        // direction is server -> client
        return false;
      end if;
    else
      select one requirement related by ifRef->C_R[R4009];
      if(empty requirement)
        // the body is on the server side yet the expected
        // direction is client -> server
        return false;
      end if;
    end if;
  end if;
  return true;
end if;',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("21f581a0-3a1c-4c9f-8ba3-9d6d3fa1c8f9",
	"11b6192c-1ebe-49e9-b164-b9f2291b604e",
	'direction',
	"57d1df51-0ab1-456e-93d3-1fbe57bba10d",
	0,
	'',
	"21f581a0-3a1c-4c9f-8ba3-9d6d3fa1c8f9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("57d1df51-0ab1-456e-93d3-1fbe57bba10d",
	"00000000-0000-0000-0000-000000000000",
	'IFDirectionType',
	'BridgePoint allows the user to specify communication direction of individual 
elements in an interface as opposed to on the interface as a whole (which is 
what UML does).  For example, in UML when an interface is specified as being 
provided, all that interface''s operations are one way (from server to 
client).  Likewise, when a interface is specified as being required, all the 
operations are one way (from client to server).  In reality, interfaces are 
not often like this. There is a mixture of client to server and server to 
client in one interface.     This enum is used at the operation/signal level 
to determine if it is to be used for client to server or server to client 
communication.',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO S_SPARM
	VALUES ("802e60c3-9344-4c41-93d3-755a16a85a56",
	"11b6192c-1ebe-49e9-b164-b9f2291b604e",
	'interface_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("11b6192c-1ebe-49e9-b164-b9f2291b604e",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("58a778aa-f31e-4cfb-bcda-108677094cdc",
	"00000000-0000-0000-0000-000000000000",
	'constant_validate',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE',
	'current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                             selected.Block_ID == current_scope;
select one body related by block->ACT_ACT[R612];
isInGenericPackage = body.associateWithContainer();
if (isInGenericPackage)
  // collect visible elements
   select one containingElem related by body->ACT_BIE[R640]->PE_PE[R640];
   select one component related by containingElem->C_C[R8001];
   select one package related by containingElem->EP_PKG[R8001];
    if not_empty component
    component.collectVisibleElementsForName(name:param.a1_name,
         type:ElementTypeConstants::CONSTANT,
                          originatingContainerID:component.Id,
                                   delegatingContainerID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true);
    else
    package.collectVisibleElementsForName(name:param.a1_name,
         type:ElementTypeConstants::CONSTANT, descending:false,
                           originatingContainerID:package.Package_ID,
                                          delegatingPkgID:GD::NULL_UNIQUE_ID(),
                                                         collectGlobally:true); 
    end if;
  select any resultSet related by component->PE_CRS[R8007] where
                                    selected.Name == param.a1_name and 
                                   selected.Type == ElementTypeConstants::CONSTANT; 
  select many results related by resultSet->PE_CVS[R8008]->PE_PE[R8004];
    if not_empty package
      select any pkgResultSet related by package->PE_SRS[R8005] where
                                     selected.Name == param.a1_name and 
                                   selected.Type == ElementTypeConstants::CONSTANT; 
      select many results related by pkgResultSet->PE_VIS[R8006]->PE_PE[R8002];
    end if;


  select many sycs related by results->CNST_CSP[R8001]->CNST_SYC[R1504] where (selected.Name == param.a1_name);
  if (cardinality sycs > 1)

      err_msg =  "There is more than one constant named ->" + param.a1_name + "<- in the system, cannot resolve.";
      ::clear_value_data();
      ERR::reportParseError( msg: err_msg, token: param.a2_ruleToken);

    return GD::NULL_UNIQUE_ID();
  elif (cardinality sycs == 0)
    if (param.a3_reportError)
      ERR::reportParseError( msg: "Cannot find constant ->%s<-",
          token: param.a2_ruleToken);
    end if;
    return GD::NULL_UNIQUE_ID();
  end if;

  create object instance scv of V_SCV;
  for each syc in sycs
    // We only loop once due to cardinality checks earlier
    relate scv to syc across R850;
  end for;

  select any val from instances of V_VAL where selected.Value_ID == param.a4_valID;
  if (empty val)
    create object instance newval of V_VAL;
    val = newval;
  end if;
  relate val to scv across R801;

  current_scope = ::get_current_scope();
  select any block from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
  relate val to block across R826;

  select one dt related by syc->S_DT[R1500];
  relate val to dt across R820;

  val.LineNumber = ::getLineNumber(rule_token: param.a2_ruleToken);
  val.StartPosition = ::getColumn(rule_token: param.a2_ruleToken);
  val.setEndPosition();

  return val.Value_ID;
else
//Specialized package behavior is kept as before 
select many sycs from instances of CNST_SYC where (selected.Name == param.a1_name );
if (cardinality sycs > 1)
  if (param.a3_reportError)
    err_msg =  "There is more than one constant named ->" + param.a1_name + "<- in this domain, cannot resolve.";
    ::clear_value_data();
    ERR::reportParseError( msg: err_msg, token: param.a2_ruleToken);
  end if;
  return GD::NULL_UNIQUE_ID();
end if;

if(empty sycs)
  // if the symbolic constant was not found, check the system level
  sysName = ::getSystemName();
  select any system from instances of S_SYS where (selected.Name == sysName);
    if (param.a3_reportError)
      ERR::reportParseError( msg: "Cannot find constant ->%s<-",
          token: param.a2_ruleToken);
    end if;
    return GD::NULL_UNIQUE_ID();

end if;

create object instance scv of V_SCV;
for each syc in sycs
  // We only loop once due to cardinality checks earlier
  relate scv to syc across R850;
end for;

select any val from instances of V_VAL where selected.Value_ID == param.a4_valID;
if (empty val)
  create object instance newval of V_VAL;
  val = newval;
end if;
relate val to scv across R801;

current_scope = ::get_current_scope();
select any block from instances of ACT_BLK where
                                           (selected.Block_ID == current_scope);
relate val to block across R826;

select one dt related by syc->S_DT[R1500];
relate val to dt across R820;

val.LineNumber = ::getLineNumber(rule_token: param.a2_ruleToken);
val.StartPosition = ::getColumn(rule_token: param.a2_ruleToken);
val.setEndPosition();

return val.Value_ID;
end if;',
	"ba5eda7a-def5-0000-0000-000000000005",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4826a0cb-c76d-4067-9750-299328ff5773",
	"58a778aa-f31e-4cfb-bcda-108677094cdc",
	'a1_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("613fc1c9-7013-4403-aaf7-2db01ef21ada",
	"58a778aa-f31e-4cfb-bcda-108677094cdc",
	'a2_ruleToken',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"4826a0cb-c76d-4067-9750-299328ff5773",
	'');
INSERT INTO S_SPARM
	VALUES ("5243942d-b3c9-4049-a10f-8f6537d5d1ea",
	"58a778aa-f31e-4cfb-bcda-108677094cdc",
	'a3_reportError',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"613fc1c9-7013-4403-aaf7-2db01ef21ada",
	'');
INSERT INTO S_SPARM
	VALUES ("ce8e0698-bd11-4aa9-8fea-f2840f705e01",
	"58a778aa-f31e-4cfb-bcda-108677094cdc",
	'a4_valID',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"5243942d-b3c9-4049-a10f-8f6537d5d1ea",
	'');
INSERT INTO PE_PE
	VALUES ("58a778aa-f31e-4cfb-bcda-108677094cdc",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	"00000000-0000-0000-0000-000000000000",
	'create_custom_token',
	'ParserValidateFunction: TRUE
ParserUtilityFunction: TRUE

Translate: native',
	'
		Token token = new Token(p_A1_token.getType() , p_A4_text);
    	token.setLine(p_A2_line);
    	token.setColumn(p_A3_column);
    	return token;',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'');
INSERT INTO S_SPARM
	VALUES ("0b119830-b472-46bd-abd5-3ee141c78b50",
	"c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	'a1_token',
	"79308373-d912-4604-b1f4-c457977e3bd2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d8160a5e-c290-4b4e-8c99-97a26124dc3d",
	"c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	'a2_line',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"0b119830-b472-46bd-abd5-3ee141c78b50",
	'');
INSERT INTO S_SPARM
	VALUES ("4812f910-d94b-407d-a1c2-aab18d3ed972",
	"c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	'a3_column',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"d8160a5e-c290-4b4e-8c99-97a26124dc3d",
	'');
INSERT INTO S_SPARM
	VALUES ("0d2c49a1-b201-49b7-a2e2-b1d91db1ad83",
	"c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	'a4_text',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4812f910-d94b-407d-a1c2-aab18d3ed972",
	'');
INSERT INTO PE_PE
	VALUES ("c4579fb5-53c1-46d5-876e-d3ec6b70f1f8",
	1,
	"450168ab-9d16-43a8-b639-cec5c575e13e",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("450168ab-9d16-43a8-b639-cec5c575e13e",
	1,
	"384b28cc-c6ad-40df-8458-61079e0f04f0",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("384b28cc-c6ad-40df-8458-61079e0f04f0",
	"00000000-0000-0000-0000-000000000000",
	"2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'Functions',
	'',
	0,
	'../Functions.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'ooaofooa',
	1,
	'../../../ooaofooa.xtuml');
