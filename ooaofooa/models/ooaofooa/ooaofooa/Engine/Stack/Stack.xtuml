-- BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

INSERT INTO O_OBJ
	VALUES ("a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'Stack',
	2910,
	'I_STACK',
	'An instance of this Core class will be created for each core or processor in the system.',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("f209a6e7-3ccf-450b-b6f7-9655c17174b3",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'run',
	'',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'//Instance:Stack.run()
self.unblock();
select one top_stack_frame related by self->I_STF[R2929];
select one blockingFrame related by top_stack_frame->I_STF[R2965.''blocked by''];
if empty top_stack_frame or not_empty blockingFrame
  self.dequeue(deliverEvents:true);
  self.unblock();
  select one top_stack_frame related by self->I_STF[R2929];
  select one blockingFrame related by top_stack_frame->I_STF[R2965.''blocked by''];
end if;
executionStateChanged = false;
if (not_empty top_stack_frame and self.runState == RunStateType::Running)
  if empty blockingFrame
    executionStateChanged = true;
    while (not_empty top_stack_frame and
                 self.runState == RunStateType::Running and empty blockingFrame)
      self.execute(force:false);
      select one top_stack_frame related by self->I_STF[R2929];
      select one blockingFrame related by
                                     top_stack_frame->I_STF[R2965.''blocked by''];
    end while;
  end if;
else
  if (self.runState == RunStateType::Running)
    self.processEvent();
    select one top_stack_frame related by self->I_STF[R2929];
    while (not_empty top_stack_frame and
                 self.runState == RunStateType::Running and empty blockingFrame)
      executionStateChanged = true;
      self.execute(force:false);
      select one top_stack_frame related by self->I_STF[R2929];
      select one blockingFrame related by
                                     top_stack_frame->I_STF[R2965.''blocked by''];
    end while;
  end if;
end if;
return executionStateChanged;
',
	1,
	'',
	"386f08f8-93cf-48b6-9de8-6096c78456d5");
INSERT INTO O_TFR
	VALUES ("386f08f8-93cf-48b6-9de8-6096c78456d5",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'push',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.push(stack_frame_id - unique_id)

// Get the instance handle to the given stack frame
select any new_stack_frame from instances of I_STF where selected.Stack_Frame_ID == param.stack_frame_id;
if (not_empty new_stack_frame)
  // Get instance handle to current top stack frame
  select one oldTop related by self->I_STF[R2929];
  if (not_empty oldTop)
    // There was a top stack frame, so remove that relationship as the top stack frame
    unrelate oldTop from self across R2929;
    
    // Relate the given stack frame as the new top stack frame
    relate new_stack_frame to self across R2929;
    
    // Relate stack to stack frame
    relate new_stack_frame to self across R2943; 
    
    // Link the stack frame chain so we can navigate through the stack
    relate oldTop to new_stack_frame across R2928.''next context'';
    
  else
    // This new stack frame will be the only stack frame, so it is the top of the stack
    relate new_stack_frame to self across R2929; 
    
    // Relate stack to stack frame
    relate new_stack_frame to self across R2943;  
  end if;

else 
     USER::logError(msg:"Error in Stack.push(stack_frame_id): no such stack frame exists in the system",path:"");
end if;
',
	1,
	'',
	"d800838f-cfcf-46c8-9b65-172908d3f7dc");
INSERT INTO O_TPARM
	VALUES ("6ec73cc1-9825-4e39-a6a5-71f29df00cd3",
	"386f08f8-93cf-48b6-9de8-6096c78456d5",
	'stack_frame_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("67a3ca34-6b69-4775-90c7-3cde92878b75",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'pop',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.pop()

// Get the instance handle to the current top stack frame
select one oldTop related by self->I_STF[R2929];

if (not_empty oldTop)
    unrelate self from oldTop across R2929;
    
       // Find the previous stack frame in the chain
    select one previous_stack_frame related by oldTop->I_STF[R2928.''previous context''];

    // Make the previous context the new top of the stack
    if (not_empty previous_stack_frame)
      unrelate oldTop from previous_stack_frame across R2928.''previous context'';
	  relate previous_stack_frame to self across R2929;
	end if;     

    if param.disposeFrame
      //  Dispose of the old stack frame, also unrelates the stack frame from this stack
      oldTop.dispose();
    end if;
    
else
    USER::logError(msg:"Attempted to pop empty stack.",path:""); 
end if;',
	1,
	'',
	"a970ff2e-622b-4e09-9345-3cf8f4bd2c71");
INSERT INTO O_TPARM
	VALUES ("6ea8bbe4-4a1a-4b54-9280-ef2571802325",
	"67a3ca34-6b69-4775-90c7-3cde92878b75",
	'disposeFrame',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("4670d8fc-a38f-4298-b7f6-ee9d65e761a2",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'dispose',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.dispose()

select one top_stack_frame related by self->I_STF[R2929];
if (not_empty top_stack_frame)
  unrelate top_stack_frame from self across R2929;
  top_stack_frame.dispose();
end if;

select one sf related by self->I_STF[R2929];
if (not_empty sf)
  unrelate self from sf across R2929; 
  sf.dispose();
end if;

select many stackFrames related by self->I_STF[R2966];
for each stackFrame in stackFrames
  select one queueEntry related by stackFrame->I_ICQE[R2966];
  unrelate self from stackFrame across R2966 using queueEntry;
  select one sendingComponent related by queueEntry->I_EXE[R2977];
  if not_empty sendingComponent
    unrelate sendingComponent from queueEntry across R2977;
  end if;
  delete object instance queueEntry;
end for;

select many stackFrames related by self->I_STF[R2967];
for each stackFrame in stackFrames
  unrelate self from stackFrame across R2967;
end for;

select many stack_frames related by self->I_STF[R2943];
for each stack_frame in stack_frames
  unrelate self from stack_frame across R2943;
  stack_frame.dispose();
end for;

select one exEng related by self->I_EXE[R2930];
if (not_empty exEng)
  unrelate self from exEng across R2930;
end if;

delete object instance self;
',
	1,
	'',
	"00000000-0000-0000-0000-000000000000");
INSERT INTO O_TFR
	VALUES ("a970ff2e-622b-4e09-9345-3cf8f4bd2c71",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'execute',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Instance::Stack.execute()
select one top_stack_frame related by self->I_STF[R2929];
select any bisf related by top_stack_frame->I_BSF[R2923] where
                                                           selected.isExecuting;
if (not_empty bisf)
  select one statement related by bisf->ACT_SMT[R2941];
  if (not_empty statement)
    if (self.runState != RunStateType::Suspended and 
               self.runState != RunStateType::Terminated and not param.force and
                      statement.checkBreakpoint(stack_id:self.Stack_ID) == true)
      self.runState = RunStateType::Suspended;
    else
      statement.execute(stack_frame_id:top_stack_frame.Stack_Frame_ID);
      // We may have a new block in stack frame context . . . 
      select any bisf related by top_stack_frame->I_BSF[R2923] where
                                                           selected.isExecuting;
      if not_empty bisf
        select one statement related by bisf->ACT_SMT[R2941];
        // If there are no statements, there is nothing to do,
        // we just want to pop up to the previous context . . .
        if empty statement
          select one block related by bisf->ACT_BLK[R2923];
          if not_empty block
            block.popUpBlock(stack_frame_id:top_stack_frame.Stack_Frame_ID);
          end if;
        end if;
      end if;
    end if;
  else
    select one block related by bisf->ACT_BLK[R2923];
    block.popUpBlock(stack_frame_id:top_stack_frame.Stack_Frame_ID);
  end if;
else
  USER::logError(msg:"Stack.execute() Error:No block found for stack frame. Terminating.",path:"");
  self.runState = RunStateType::Terminated;
end if;',
	1,
	'',
	"4670d8fc-a38f-4298-b7f6-ee9d65e761a2");
INSERT INTO O_TPARM
	VALUES ("c8be443e-39fa-4b42-b1f3-8ec66abfda06",
	"a970ff2e-622b-4e09-9345-3cf8f4bd2c71",
	'force',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("d800838f-cfcf-46c8-9b65-172908d3f7dc",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'processEvent',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'signalFound = false;
// Signals are processed as soon as there
// is a possible chance, which is once a
// currently executing activity has completed

select one exEng related by self->I_EXE[R2930];

// Check self event queue
selfEventFound = false;
if(not signalFound and not_empty exEng)
  exEng.lockQueue(queue_name:"I_SQE");

  select many pendingSelfEvtQEntries related by exEng->I_SQE[R2946];
  for each pendingSelfEvtQEntry in pendingSelfEvtQEntries
    select one prevSelfEvtQEntry related by pendingSelfEvtQEntry
                                                      ->I_SQE[R2947.''precedes''];
    if (empty prevSelfEvtQEntry)
      select one evt related by pendingSelfEvtQEntry->I_EVI[R2946];
      select one inst related by evt->I_INS[R2935];
      if (not_empty inst)
        inst.takeEvent(stack_id: self.Stack_ID, step_in:false,
                 event_queue_entry_id:pendingSelfEvtQEntry.Self_Queue_Entry_ID);
        selfEventFound = true;
        break;
      else
        select one cie related by evt->CSME_CIE[R2931];
        if (not_empty cie)
          cie.takeEvent(stack_id: self.Stack_ID, step_in:false,
                  event_queue_entry_id:pendingSelfEvtQEntry.Self_Queue_Entry_ID);
          selfEventFound = true;
          break;
        else
          event_name = "unknown name";
          select one sm_evt related by evt->SM_EVT[R2906];
          path="";
          if (not_empty sm_evt)
            event_name = sm_evt.get_name();
            path = sm_evt.getPath();
          end if;
          USER::logError(msg:"Could not find target for event ",path:"");
        end if;
      end if;
    end if;
  end for;
  exEng.unlockQueue(queue_name:"I_SQE");
end if;
if (not selfEventFound and not_empty exEng)
  // Check inter-instance event queue
  exEng.lockQueue(queue_name:"I_EQE");
  select many pendingEvtQEntries related by exEng->I_EQE[R2944];
  for each pendingEvtQEntry in pendingEvtQEntries
    select one prevEvtQEntry related by pendingEvtQEntry
                                                      ->I_EQE[R2945.''precedes''];
    if (empty prevEvtQEntry)
      select one evt related by pendingEvtQEntry->I_EVI[R2944];
      select one inst related by evt->I_INS[R2935];
      if (not_empty inst)
        inst.takeEvent(stack_id: self.Stack_ID, step_in:false,
                    event_queue_entry_id:pendingEvtQEntry.Event_Queue_Entry_ID);
        break;
      else
        select one cie related by evt->CSME_CIE[R2931];
        if (not_empty cie)
          cie.takeEvent(stack_id: self.Stack_ID, step_in:false,
            event_queue_entry_id:pendingEvtQEntry.Event_Queue_Entry_ID);
            break;
        else
          event_name = "unknown name";
          select one sm_evt related by evt->SM_EVT[R2906];
          path="";
          if (not_empty sm_evt)
            event_name = sm_evt.get_name();
            path= sm_evt.getPath();
          end if;
          USER::logError(msg:"Could not find target for event " + event_name,path:path);
        end if;
      end if;
    end if;
  end for;
  exEng.unlockQueue(queue_name:"I_EQE");
end if;',
	1,
	'',
	"67a3ca34-6b69-4775-90c7-3cde92878b75");
INSERT INTO O_TFR
	VALUES ("28bed7c9-c659-433b-8299-0eeb68d90c4a",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'stepIn',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'//Instance:Stack.stepIn()
self.runState = RunStateType::Stepping;
self.suspendReason = "";
select one top_stack_frame related by self->I_STF[R2929];
if (not_empty top_stack_frame)
  select one blockingFrame related by
                                     top_stack_frame->I_STF[R2965.''blocked by''];
  if empty blockingFrame
    self.execute(force:true);
  end if; 
else
  self.processEvent();
end if;
self.runState = RunStateType::Suspended;',
	1,
	'',
	"f209a6e7-3ccf-450b-b6f7-9655c17174b3");
INSERT INTO O_TFR
	VALUES ("0e569cf4-f8d0-44ae-ab0c-6b5242ed516b",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'stepOver',
	'',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'//Instance:Stack.stepOver()
self.runState = RunStateType::Stepping;
self.suspendReason = "";
select any cur_stack_frame related by self->I_STF[R2943] where
                                selected.Stack_Frame_ID == param.stack_frame_id;
if (not_empty cur_stack_frame)
  // We''re stepping over some OAL
  self.execute(force:true);
  select one top_stack_frame related by self->I_STF[R2929];
  select one blockingFrame related by
                                     top_stack_frame->I_STF[R2965.''blocked by''];
  // If the statement causes a stack frame change, continue
  // running until the old stack frame is back on top
  select many valueInStackFrames related by cur_stack_frame->I_VSF[R2951];
  select any whereClauseReference related by cur_stack_frame->
                         I_BSF[R2923]->L_LCL[R3000]->L_LSR[R3001]->L_IWC[R3006];
  while (self.runState == RunStateType::Stepping and
             (not_empty top_stack_frame and empty blockingFrame) and
             ((not cur_stack_frame.isDisposed() and
                              top_stack_frame != cur_stack_frame) or
              (not_empty valueInStackFrames or not_empty whereClauseReference)))
    // We still have stack frames to execute (not_empty top_stack_frame) and
    // We''re not blocked by an intercomponent message (empty blockedFrame) and
    // We didn''t step out of an action (cur_stack_frame.isDisposed()) and 
    // We haven''t returned to the context we were stepping in
    //                                   (top_stack_frame != cur_stack_frame) or
    // There is outstanding value computation occurring
    //                                            (not_empty valueInStackFrames)
    // There is outstanding where clause selection occurring
    //                                          (not_empty whereClauseReference)
    self.execute(force:false);
    select one top_stack_frame related by self->I_STF[R2929];
    select many valueInStackFrames related by cur_stack_frame->I_VSF[R2951];
    select any whereClauseReference related by cur_stack_frame->
                         I_BSF[R2923]->L_LCL[R3000]->L_LSR[R3001]->L_IWC[R3006];
    select one blockingFrame related by
                                   top_stack_frame->I_STF[R2965.''blocked by''];     
  end while;
else
  // we''re stepping over an event
  self.processEvent();
  select one top_stack_frame related by self->I_STF[R2929];
  while (self.runState == RunStateType::Stepping and not_empty top_stack_frame)
    self.execute(force:false);
    select one top_stack_frame related by self->I_STF[R2929];
  end while;
end if;
self.runState = RunStateType::Suspended;',
	1,
	'',
	"28bed7c9-c659-433b-8299-0eeb68d90c4a");
INSERT INTO O_TPARM
	VALUES ("878cb06e-b914-4df1-a715-69087525c1fc",
	"0e569cf4-f8d0-44ae-ab0c-6b5242ed516b",
	'stack_frame_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("3bc9a23a-8753-434d-9479-9a0dfdb6d483",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'enqueue',
	'synchronized:true',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.enqueue(stack_frame_id)

// Get the instance handle to the given stack frame
select any new_stack_frame from instances of I_STF
                          where selected.Stack_Frame_ID == param.stack_frame_id;
if (not_empty new_stack_frame)
  // Get instance handle to current top stack frame
  select many queuedFrames related by self->I_ICQE[R2966]->I_STF[R2966];
  if param.isActivity == false
     // We need the result queue
     select many queuedFrames related by self->I_STF[R2967];
  end if;
  select any lastFrame from instances of I_STF where
                                selected.Stack_Frame_ID == GD::NULL_UNIQUE_ID();
  // Find the stack frame at the top of the queue
  for each candidateFrame in queuedFrames
    select one prevFrame related by
                                candidateFrame->I_STF[R2928.''previous context''];
    if empty prevFrame
      lastFrame = candidateFrame;
      break;
    end if;
  end for;
  if param.isActivity == true
    //put it on the activity queue
    create object instance queueEntry of I_ICQE;
    relate new_stack_frame to self across R2966 using queueEntry;
    select any remoteStackFrame from instances of I_STF where
                         selected.Stack_Frame_ID == param.remote_stack_frame_id;
    if not_empty remoteStackFrame
      select one remoteComponentInstance related by remoteStackFrame->
                                                   I_STACK[R2943]->I_EXE[R2930];
      relate remoteComponentInstance to queueEntry across R2977;
    end if;
  else
    //put it on the result queue
    relate new_stack_frame to self across R2967;
  end if;
  if (not_empty lastFrame)
    // There was a top stack frame, so link up the list
    relate lastFrame to new_stack_frame across R2928.''previous context'';
  end if;
else 
  USER::logError(msg:"Error in Stack.enqueue(stack_frame_id): no such stack frame exists in the system",path:"");
end if;
',
	1,
	'',
	"0e569cf4-f8d0-44ae-ab0c-6b5242ed516b");
INSERT INTO O_TPARM
	VALUES ("7a5fce9f-564a-446d-8e7e-2c806ce5985c",
	"3bc9a23a-8753-434d-9479-9a0dfdb6d483",
	'stack_frame_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TPARM
	VALUES ("4e907c08-a092-4c45-b91f-0ed7f63a575a",
	"3bc9a23a-8753-434d-9479-9a0dfdb6d483",
	'isActivity',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"7a5fce9f-564a-446d-8e7e-2c806ce5985c",
	'');
INSERT INTO O_TPARM
	VALUES ("bdec13fe-7518-4b98-8c2b-24784e721894",
	"3bc9a23a-8753-434d-9479-9a0dfdb6d483",
	'remote_stack_frame_id',
	"ba5eda7a-def5-0000-0000-000000000005",
	0,
	'',
	"4e907c08-a092-4c45-b91f-0ed7f63a575a",
	'');
INSERT INTO O_TFR
	VALUES ("653cd143-ac92-406a-8529-b8138c240c0f",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'dequeue',
	'synchronized:true',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.dequeue()
// Service incoming intercomponent messages.
select many queuedFrames related by self->I_STF[R2966];
select any topFrame from instances of I_STF where
                                selected.Stack_Frame_ID == GD::NULL_UNIQUE_ID();
// Find the stack frame at the top of the queue
for each candidateFrame in queuedFrames
  select one nextFrame related by candidateFrame->I_STF[R2928.''next context''];
  if empty nextFrame
    topFrame = candidateFrame;
    break;
  end if;
end for;
if not_empty topFrame and topFrame.readyForInterrupt == true
  select one prevFrame related by topFrame->I_STF[R2928.''previous context''];
  if not_empty prevFrame
    unrelate topFrame from prevFrame across R2928.''previous context'';
  end if;
  select one queueEntry related by topFrame->I_ICQE[R2966];
  select one sendingComponent related by queueEntry->I_EXE[R2977];
  if not_empty sendingComponent
    unrelate sendingComponent from queueEntry across R2977;
  end if;
  unrelate self from topFrame across R2966 using queueEntry;
  delete object instance queueEntry;
  select any reqSig related by topFrame->I_BSF[R2923]->ACT_BLK[R2923]->
                                     ACT_ACT[R601]->ACT_RSB[R698]->SPR_RS[R684];
  select any provSig related by topFrame->I_BSF[R2923]->ACT_BLK[R2923]->
                                     ACT_ACT[R601]->ACT_PSB[R698]->SPR_PS[R686];
  select one sigEvt related by reqSig->SM_SGEVT[R529];
  select one ep related by reqSig->SPR_REP[R4502]->C_EP[R4500];
  if not_empty provSig
    select one sigEvt related by provSig->SM_SGEVT[R528];
    select one ep related by provSig->SPR_PEP[R4503]->C_EP[R4501];
  end if;
  if not_empty sigEvt and param.deliverEvents
    select one evt related by sigEvt->SM_SEVT[R526]->SM_EVT[R525];
    create object instance pendingEvt of I_EVI;
    select one ci related by self->I_EXE[R2930];
    relate pendingEvt to ci across R2964;
    relate pendingEvt to sendingComponent across R2976;
    relate evt to pendingEvt across R2906;
    select many args related by ep->C_PP[R4006];
    select any cursor related by ep->C_PP[R4006];
    for each arg in args
      select one nextArg related by arg->C_PP[R4021.''succeeds''];
      if empty nextArg
        cursor = arg;
        break;
      end if;
    end for;
    while not_empty cursor
      select any localValue related by topFrame->I_BSF[R2923]->L_LCL[R3000]->
                              L_LVL[R3001] where selected.PP_Id == cursor.PP_Id;
      select one local related by localValue->L_LCL[R3001];
      select one runtimeVal related by local->RV_RVL[R3306];
      create object instance eventVal of I_DIV;
      relate eventVal to cursor across R2956;
      relate eventVal to pendingEvt across R2933;
      create object instance eventRuntimeVal of RV_RVL;
      eventRuntimeVal.copyValue(from:runtimeVal.RuntimeValue_ID);
      relate eventRuntimeVal to eventVal across R3303;
      select one cursor related by cursor->C_PP[R4021.''precedes''];     
    end while;
    pendingEvt.fire();
    topFrame.dispose(); 
  else
    self.push(stack_frame_id:topFrame.Stack_Frame_ID);
  end if;
end if;',
	1,
	'',
	"3bc9a23a-8753-434d-9479-9a0dfdb6d483");
INSERT INTO O_TPARM
	VALUES ("020ade36-aed6-4b4b-b8b9-055ecd2d43e1",
	"653cd143-ac92-406a-8529-b8138c240c0f",
	'deliverEvents',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO O_TFR
	VALUES ("62e10774-042a-41be-a0d4-a4582a44f9bf",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	'unblock',
	'synchronized:true',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'// Stack.unblock()
// Deal with any returned data from an interface operation call
// and unblock the stack.
select many queuedFrames related by self->I_STF[R2967];
for each frame in queuedFrames
  if frame.readyForInterrupt == true
    // Following policy is similar to that in the local part of
    // ReturnStmt.execute() because it is doing basically the same job.
    // get the computed result
    select one blockedFrame related by frame->I_STF[R2965.''blocks''];
    select one stack related by blockedFrame->I_STACK[R2929];
    if not_empty stack
      // We only want to process result frames for the top stack frame.
      // No stack here means the blocked frame isn''t the top one across R2929.
      select any result related by frame->I_VSF[R2951];
      select one rtVal related by result->RV_RVL[R3305];
      // Now locate the required target frame
      select many targetResults related by blockedFrame->I_VSF[R2951] where
                               selected.RuntimeValue_ID == GD::NULL_UNIQUE_ID();
      // Set the value of the last one in the set . . .
      resultCount = cardinality targetResults;
      if resultCount > 0
        for each targetResult in targetResults
          resultCount = resultCount - 1;
          if (resultCount == 0)
            create object instance newRtVal of RV_RVL;
            relate newRtVal to targetResult across R3305;
            select one dt related by targetResult->V_VAL[R2978]->S_DT[R820];
            relate newRtVal to dt across R3307;
            newRtVal.copyValue(from:rtVal.RuntimeValue_ID);
            rtVal.dispose();
            unrelate self from frame across R2967;
            unrelate frame from blockedFrame across R2965.''blocks'';
            // The remote frames result is now copied into the local frame
            // where it is needed and the local frame is unblocked. We can now
            // dispose the frame.
            frame.dispose(); 
            break;
          end if;
        end for;
      else
        // void return frame
        unrelate self from frame across R2967;
        unrelate frame from blockedFrame across R2965.''blocks'';
        frame.dispose();
        // The blocked frame is ready to continue execution,
        // move it to the next statement. 
        if not_empty blockedFrame
          // Note this policy is mirrored closely by the policy found at the end
          // of Statement.execute(). Any changes here should be reviewed for
          // inclusion there.
          select any bisf related by blockedFrame->I_BSF[R2923] where
                                                           selected.isExecuting;
          select one currentStatement related by bisf->ACT_SMT[R2941];
          //
          // If there are any intermediate values on the stack frame, then this
          // indicates that processing has been interrupted during a value
          // computation. We do not want to progress to the next statement in
          // this case.
          //
          select any intermediateValue related by blockedFrame->I_VSF[R2951];
          //
          // If there is an instance associated with a selection reference, then
          // a where clause is being executed. We do not want to progress to the
          // next statement in that case either.
          //
          select one outer_block related by bisf->ACT_BLK[R2923]->
                                                   ACT_ACT[R601]->ACT_BLK[R666];
          select any outer_bisf related by blockedFrame->I_BSF[R2923]
                                where selected.Block_ID == outer_block.Block_ID;
          select any select_where_inst_ref related by outer_bisf->
                                       L_LCL[R3000]->L_LSR[R3001]->L_IWC[R3006];
          //
          // If a statement is blocked on an intercomponent call, we do not want
          // to progress to the next statement either.
          //
          select one blockingFrame related by blockedFrame->
                                                      I_STF[R2965.''blocked by''];
  
          if (empty intermediateValue and empty select_where_inst_ref and
                                 not_empty bisf and bisf.isExecuting and
                                                            empty blockingFrame)
            // There was no scope change, so we need to advance our program
            // counter association, R2941. If the scope had changed, the
            // statement subtype would have already set up a new instance of
            // this association and would have created whatever new stack frame
            // and block in stack frame instances were needed.
            //
            if not_empty currentStatement
              currentStatement.setupNextStatement(
                                    stack_frame_id:blockedFrame.Stack_Frame_ID);
            else
              // The block is empty, must be a realized component.
              // We do nothing, since disposal of the stack frame
              // is managed in the realized code interface.
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
end for;',
	1,
	'',
	"653cd143-ac92-406a-8529-b8138c240c0f");
INSERT INTO O_NBATTR
	VALUES ("50392142-b7d5-416a-a35f-c9aabc976740",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_BATTR
	VALUES ("50392142-b7d5-416a-a35f-c9aabc976740",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_ATTR
	VALUES ("50392142-b7d5-416a-a35f-c9aabc976740",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"00000000-0000-0000-0000-000000000000",
	'Stack_ID',
	'',
	'',
	'Stack_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000005",
	'',
	'');
INSERT INTO O_NBATTR
	VALUES ("0e3e9363-030a-40f9-934b-dd119d755a63",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_BATTR
	VALUES ("0e3e9363-030a-40f9-934b-dd119d755a63",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_ATTR
	VALUES ("0e3e9363-030a-40f9-934b-dd119d755a63",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"9f68c383-f0bd-4e03-bf91-9cdf5e44b79d",
	'runState',
	'',
	'',
	'runState',
	0,
	"04c08383-57a3-4c62-9e28-10fb75da1f99",
	'',
	'');
INSERT INTO S_DT_PROXY
	VALUES ("04c08383-57a3-4c62-9e28-10fb75da1f99",
	"00000000-0000-0000-0000-000000000000",
	'RunStateType',
	'',
	'',
	'../../Datatypes/Datatypes.xtuml');
INSERT INTO O_NBATTR
	VALUES ("9bc5f5de-4451-4564-a69b-f8653d10e9dd",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_BATTR
	VALUES ("9bc5f5de-4451-4564-a69b-f8653d10e9dd",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_ATTR
	VALUES ("9bc5f5de-4451-4564-a69b-f8653d10e9dd",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"0e3e9363-030a-40f9-934b-dd119d755a63",
	'suspendReason',
	'',
	'',
	'suspendReason',
	0,
	"ba5eda7a-def5-0000-0000-000000000004",
	'',
	'');
INSERT INTO O_REF
	VALUES ("a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"7e45ee45-6a73-41bb-9135-189c5ce8a010",
	0,
	"8737e339-840c-4a57-a139-d2dae6d1b3ad",
	"d7079b91-adab-418b-9444-e169e1a6e8b2",
	"4eaf1529-81b9-4c31-a831-804718b2900f",
	"0ad7f3ab-3eba-4234-bf2a-8b1cc59426bc",
	"9f68c383-f0bd-4e03-bf91-9cdf5e44b79d",
	"fad9914d-2806-436d-b3a1-22c4a51d0d97",
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'Component Instance',
	'Execution_Engine_ID',
	'R2930.''is controlled by''');
INSERT INTO R_RGO_PROXY
	VALUES ("a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"d7079b91-adab-418b-9444-e169e1a6e8b2",
	"4eaf1529-81b9-4c31-a831-804718b2900f",
	'../Engine.xtuml');
INSERT INTO O_RTIDA_PROXY
	VALUES ("8737e339-840c-4a57-a139-d2dae6d1b3ad",
	"7e45ee45-6a73-41bb-9135-189c5ce8a010",
	0,
	"d7079b91-adab-418b-9444-e169e1a6e8b2",
	"0ad7f3ab-3eba-4234-bf2a-8b1cc59426bc",
	'../Engine.xtuml');
INSERT INTO O_RATTR
	VALUES ("9f68c383-f0bd-4e03-bf91-9cdf5e44b79d",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"8737e339-840c-4a57-a139-d2dae6d1b3ad",
	"7e45ee45-6a73-41bb-9135-189c5ce8a010",
	1,
	'Execution_Engine_ID');
INSERT INTO O_BATTR_PROXY
	VALUES ("8737e339-840c-4a57-a139-d2dae6d1b3ad",
	"7e45ee45-6a73-41bb-9135-189c5ce8a010",
	'../../Instance/Component Instance/Component Instance.xtuml');
INSERT INTO O_ATTR
	VALUES ("9f68c383-f0bd-4e03-bf91-9cdf5e44b79d",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	"50392142-b7d5-416a-a35f-c9aabc976740",
	'Execution_Engine_ID',
	'',
	'',
	'Execution_Engine_ID',
	0,
	"ba5eda7a-def5-0000-0000-000000000007",
	'',
	'');
INSERT INTO O_ID
	VALUES (0,
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_OIDA
	VALUES ("50392142-b7d5-416a-a35f-c9aabc976740",
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	0,
	'Stack_ID');
INSERT INTO O_ID
	VALUES (1,
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO O_ID
	VALUES (2,
	"a520a952-2404-4fe6-b8f6-79cd5ff8ce42");
INSERT INTO PE_PE
	VALUES ("a520a952-2404-4fe6-b8f6-79cd5ff8ce42",
	1,
	"500505f0-102c-43a8-bcf8-681925418cc6",
	"00000000-0000-0000-0000-000000000000",
	4);
INSERT INTO EP_PKG_PROXY
	VALUES ("500505f0-102c-43a8-bcf8-681925418cc6",
	"00000000-0000-0000-0000-000000000000",
	"2f3ea6a7-20e9-405c-b68c-7fba041e7daf",
	'Engine',
	'// This is used by schema_gen to ignore this subsystem (for publication)
TRANSLATE_FOR_EXTERNAL_USE:FALSE
Persistent:false
Import: java.util.concurrent.locks.ReentrantLock',
	900,
	'../Engine.xtuml');
